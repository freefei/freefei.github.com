<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Ryan Hoo]]></title>
  <link href="http://ryanhoo.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://ryanhoo.github.io/"/>
  <updated>2014-08-08T17:43:12+08:00</updated>
  <id>http://ryanhoo.github.io/</id>
  <author>
    <name><![CDATA[Ryan Hoo]]></name>
    <email><![CDATA[ryan.hoo.j@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Parallax Animation]实现知乎 Android 客户端启动页视差滚动效果]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/07/16/step-by-step-implement-parallax-animation-for-splash-screen-of-zhihu/"/>
    <updated>2014-07-16T18:22:58+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/07/16/step-by-step-implement-parallax-animation-for-splash-screen-of-zhihu</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">前言</a></li>
  <li><a href="#section-1">界面分析</a></li>
  <li><a href="#parallax-scrolling">Parallax Scrolling</a>    <ul>
      <li><a href="#viewpagerpagetransformer">ViewPager.PageTransformer</a>        <ul>
          <li><a href="#param-1-view-page">Param 1: View page</a></li>
          <li><a href="#param-2-float-position">Param 2: float position</a></li>
        </ul>
      </li>
      <li><a href="#parallaxtransformer">ParallaxTransformer</a></li>
    </ul>
  </li>
  <li><a href="#section-2">背景渐变</a></li>
  <li><a href="#section-3">源码</a>    <ul>
      <li><a href="#github--zhihu-parallax-animation3">Github : <a href="https://github.com/ryanhoo/Zhihu-Parallax-Animation">Zhihu-Parallax-Animation</a></a></li>
    </ul>
  </li>
  <li><a href="#section-4">参考</a></li>
</ul>

<blockquote>
  <p>欢迎转载，但请务必注明出处！</p>

  <p><a href="http://ryanhoo.github.io/blog/2014/07/16/step-by-step-implement-parallax-animation-for-splash-screen-of-zhihu/">http://ryanhoo.github.io/blog/2014/07/16/step-by-step-implement-parallax-animation-for-splash-screen-of-zhihu/</a></p>
</blockquote>

<h1 id="section">前言</h1>

<p><code>Parallax Scrolling (视差滚动)</code>，是一种常见的动画效果。视差一词来源于天文学，但在日常生活中也有它的身影。在疾驰的动车上看风景时，会发现越是离得近的，相对运动速度越快，而远处的山川河流只是缓慢的移动着，这就是最常见的视差效果。视差动画独有的层次感能带来极为逼真的视觉体验，<strong>iOS</strong>、<strong>Android Launcher</strong>、<strong>Website</strong> 都将视差动画作为提升用户视觉愉悦度的不二选择。</p>

<p>客户端应用第一次打开出现引导页也不是什么新鲜的事儿，<code>ViewPager</code> 配上几张设计师精心绘制的图片，分分钟即可了事。但是总有人把平凡的事情做到不平凡，如本文的知乎客户端，亦或是新浪微博贺岁版，百度贴吧某版等众多应用里都出现了视差动画的身影，随着用户手指的滑动，反馈以灵动、贴近真实的视觉以及操作体验，对应用的初始印象登时被提升到一个极高的点。</p>

<p>给我印象最深的是去年新浪微博的贺岁版，引导页是一系列的年画，里面有红色剪纸的小孩儿，滑动界面的时候感觉这些元素在『动』，是真正的灵动，能勾起人童年的回忆，年味儿十足。不过话说我年怎么过跟新浪微博一毛钱关系都没有，但是这个启动页却是深得我意。只是这个版本的微博找不到了，正好前两天看到知乎的启动页做的也不错，就正好拿来练练手吧。</p>

<p>本文就知乎 Android 客户端启动页面为例，教你如何实现视差滚动效果。</p>

<p><img src="/images/blog/android/zhihu-parallax-animation.gif" alt="知乎 Android 客户端启动页" /></p>

<h1 id="section-1">界面分析</h1>

<p>细心把玩下知乎的启动页，不难分析出来，视差动画主要体现在背景层渐变、内容层元素差异滚动上，动画内容分别是：</p>

<ul>
  <li>内容：元素差异滚动，形成视差效果(*)</li>
  <li>背景：随着界面的滑动，颜色由深蓝色渐变为浅蓝色(*)</li>
  <li>文字：底部提示文案会随页面变动而切换，有简单的淡入淡出效果</li>
  <li>界面动画：界面打开，元素的出场动画（第一页以及最后一页）</li>
</ul>

<p>鉴于其它几项比较简单，本文主要讲视差动画以及背景渐变的实现，其它几项请自行参阅代码，见后文。</p>

<h1 id="parallax-scrolling">Parallax Scrolling</h1>

<p>这里的视差滚动效果，主要表现为内容元素滚动速率的差异上。比如在 <code>ViewPager</code> 中滑动了 <code>1px</code> ，而 <strong>A</strong> 元素移动 <code>2px</code> ， <strong>B</strong> 元素移动 <code>1.5px</code> ，这种移动差距的比率，我称之为 <code>parallaxCofficient</code> ，即 <strong>视差系数</strong> 或者 <strong>视差速率</strong> ，正是同一个界面中的元素，由于层级不同，赋予的视差系数不同，在移动速度上的差异形成了视差的错觉，这就是我们要追求的效果。</p>

<p>那知道原理就好办了，使用 <code>ViewPager.OnPageChangeListener</code> ，动态计算不就得了。 no no no ! 后面完成背景渐变效果确实需要计算这个，但是 <code>ViewPager</code> 已经为我们准备好了变形元素 <strong>transformium</strong> : <code>ViewPager.PageTransformer</code> ，它有一个抽象方法 <code>transformPage(View page, float position)</code> ，正是为我们完成视差动画量身定制的。</p>

<h2 id="viewpagerpagetransformer">ViewPager.PageTransformer</h2>

<p><a href="https://developer.android.com/reference/android/support/v4/view/ViewPager.PageTransformer.html">PageTransformer</a> 在 <code>ViewPager</code> 滑动时被触发，它为我们自定义页面中进行视图变换打开了一扇大门。</p>

<p><code>java
public abstract void transformPage (View page, float position)
</code></p>

<p>在 <code>ViewPager</code> 源码中，我们可以很直观的看到它的调用过程：</p>

<p>```java
// ViewPager#onPageScrolled
if (mPageTransformer != null) {
    final int scrollX = getScrollX();
    final int childCount = getChildCount();
    for (int i = 0; i &lt; childCount; i++) {
        final View child = getChildAt(i);
        final LayoutParams lp = (LayoutParams) child.getLayoutParams();</p>

<pre><code>    if (lp.isDecor) continue;

    final float transformPos = (float) (child.getLeft() - scrollX) / getClientWidth();
    mPageTransformer.transformPage(child, transformPos);
} } ```
</code></pre>

<h4 id="param-1-view-page">Param 1: View page</h4>

<p>从上面的代码中，不难看出，<code>page</code> 就是当前被滑动的页面，调试得知，每一个 <strong>child view</strong> 被 <code>NoSaveStateFrameLayout</code> 包装，也就是说 <code>page.getChildAt(0)</code> 即是每个 <code>page</code> 实际的 <strong>child view</strong> 。</p>

<h4 id="param-2-float-position">Param 2: float position</h4>

<p><code>position</code> 这个参数不看代码或者文档，总会误以为就是我们熟知的 <code>integer position</code> ，不过它实际上是滑动页面的一个相对比例，本质跟 1、2、3、4 这种 <code>position</code> 是一样的。</p>

<p>比如知乎启动页共有 <strong>6</strong> 个页面，分别是 <strong>A</strong>、<strong>B</strong>、<strong>C</strong>、<strong>D</strong>、<strong>E</strong>、<strong>F</strong> 初始状态也就是 <strong>A</strong> 页面静止时，<strong>A</strong> 页面的 <code>position</code> 正好是 <strong>0</strong> ，<strong>B</strong> 页面是 <strong>1</strong> 。而后滑动页面（B -&gt; A），在这个过程中 <strong>A</strong> 的 <code>position</code> 是间于 <code>[-1, 0]</code> ，<strong>B</strong> 页面则是间于 <code>[0, 1]</code> 。</p>

<p>不过这个参数的文档却是简单不够直观，对照上面的例子，现在应该很清晰了。</p>

<blockquote>
  <p>Position of page relative to the current front-and-center position of the pager. 0 is front and center. 1 is one full page position to the right, and -1 is one page position to the left.</p>
</blockquote>

<h2 id="parallaxtransformer">ParallaxTransformer</h2>

<p>根据上面的分析，我们可以得出一个相对简单的自定义 <strong>transformer</strong> ，对 <code>page view</code> 进行遍历，递增或者递减其 <code>parallaxCofficient</code> ，以得到我们预期的效果，具体的系数设置请参考代码。</p>

<p>```java
class ParallaxTransformer implements ViewPager.PageTransformer {</p>

<pre><code>float parallaxCoefficient;
float distanceCoefficient;

public ParallaxTransformer(float parallaxCoefficient, float distanceCoefficient) {
    this.parallaxCoefficient = parallaxCoefficient;
    this.distanceCoefficient = distanceCoefficient;
}

@Override
public void transformPage(View page, float position) {
    float scrollXOffset = page.getWidth() * parallaxCoefficient;

    // ...
    // layer is the id collection of views in this page
    for (int id : layer) {
        View view = page.findViewById(id);
        if (view != null) {
            view.setTranslationX(scrollXOffset * position);
        }
        scrollXOffset *= distanceCoefficient;
    }
} } ```
</code></pre>

<h1 id="section-2">背景渐变</h1>

<p>留心才会发现，从第一页滑动到最后一页，背景色会平滑的从深蓝色过度到浅蓝色，这种效果又该怎么实现呢？</p>

<p>用过 <code>Property Animation</code> 的同学应该知道，以前的 <code>Animation</code> 只能用在 <strong>View</strong> 上，而 <code>Property Animation</code> 却可以用在任意类型属性值上，这归功于 <code>TypeEvaluator</code> 。</p>

<p>正好我们有 <code>ArgbEvaluator</code> ，它可以估算两个颜色值之间，任意部分的色值。因此，只需要指定起始色值以及最终的色值，传入滑动所对应的 <code>fraction</code> 即当前位置相对总距离的比例值，即可获得相应的色值。</p>

<p>```java
public class ArgbEvaluator implements TypeEvaluator {</p>

<pre><code>public Object evaluate(float fraction, Object startValue, Object endValue) {
	// ...
} } ```
</code></pre>

<p>当然，前面说到需要使用 <code>ViewPager.OnPageChangeListener</code> 的：</p>

<p>```java
class GuidePageChangeListener implements ViewPager.OnPageChangeListener {</p>

<pre><code>ArgbEvaluator mColorEvaluator;

int mPageWidth, mTotalScrollWidth;

int mGuideStartBackgroundColor, mGuideEndBackgroundColor;

public GuidePageChangeListener() {
    mColorEvaluator = new ArgbEvaluator();

    mPageWidth = getWindowManager().getDefaultDisplay().getWidth();
    mTotalScrollWidth = mPageWidth * mAdapter.getCount();

    mGuideStartBackgroundColor = getResources().getColor(R.color.guide_start_background);
    mGuideEndBackgroundColor = getResources().getColor(R.color.guide_end_background);
}

@Override
public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
    float ratio = (mPageWidth * position + positionOffsetPixels) / (float) mTotalScrollWidth;
    Integer color = (Integer) mColorEvaluator.evaluate(ratio, mGuideStartBackgroundColor, mGuideEndBackgroundColor);
    mPager.setBackgroundColor(color);
}

@Override
public void onPageSelected(int position) {}

@Override
public void onPageScrollStateChanged(int state) {} } ```
</code></pre>

<h1 id="section-3">源码</h1>

<p>代码已经 <strong>push</strong> 到 <strong>Github</strong> 了，诸位自取。不过请注意，其素材均取自于知乎 Android 客户端（你懂的），学习交流即可，请勿用作商业用途。</p>

<p>还求更优雅的实现方式，欢迎发起 <code>pull request</code> 。</p>

<h2 id="github--zhihu-parallax-animation3">Github : <a href="https://github.com/ryanhoo/Zhihu-Parallax-Animation">Zhihu-Parallax-Animation</a></h2>

<h1 id="section-4">参考</h1>

<ol>
  <li><a href="http://blog.neteril.org/blog/2014/01/02/using-parallax-for-fun-and-profit/">Using Parallax for Fun and Profit</a></li>
  <li><a href="http://www.cnblogs.com/JoannaQ/archive/2013/02/08/2909111.html">视差滚动(Parallax Scrolling)效果的原理和实现</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Timer(Task) ？ Not in Android ！]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/26/do-not-use-timer-in-android/"/>
    <updated>2014-06-26T20:55:04+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/26/do-not-use-timer-in-android</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">前言</a></li>
  <li><a href="#section-1">解决方案</a>    <ul>
      <li><a href="#timer">Timer</a></li>
      <li><a href="#timertask">TimerTask</a></li>
      <li><a href="#section-2">操作定时任务</a></li>
    </ul>
  </li>
  <li><a href="#section-3">参考</a></li>
</ul>

<h2 id="section">前言</h2>

<p>我们对于 <code>java.util.Timer(Task)</code> 这两个类可谓不陌生，定时任务处处可见它俩如胶似漆的背影。只是，有心人必定会发现在 <strong>Android UI</strong> 中使用，它们带来的麻烦远远大于便利。</p>

<p>我在多个场景碰到过这个问题，往往是忍气吞声，不厌其烦的处理着它们的『身后事』，还得提防它们时而罢工的臭毛病。</p>

<h2 id="section-1">解决方案</h2>

<p>其实使用 Android 自己的 <a href="https://developer.android.com/reference/android/os/Handler.html">Handler</a> 就可以解决这个问题。而且有如下优点：</p>

<ul>
  <li>重用</li>
</ul>

<p>可以很好的重用我们的定时任务，而以往使用 <code>Timer(Task)</code> ，我们不得不销毁，再 <code>new Timer(Task)</code>，不得不说是一种很粗鲁的方式。</p>

<ul>
  <li>可控性</li>
</ul>

<p><code>Timer(Task)</code> 的组合更像是离弦之箭，不能收发自如。而使用 <code>Handler</code> 的方式，调用 <code>removeCallbacks</code> 即可轻松暂停或者重置任务。</p>

<h3 id="timer">Timer</h3>

<p>使用 <a href="https://developer.android.com/reference/android/os/Handler.html">Handler</a> 来替代 <a href="https://developer.android.com/reference/java/util/Timer.html">Timer</a>。</p>

<p><code>java
Handler timerHandler = new Handler()
</code></p>

<h3 id="timertask">TimerTask</h3>

<p>简单可重用的 <code>Runnable</code> ，用来执行定时任务，但是这里是用的比较 <strong>Hack</strong> 的方式来实现循环的 Timer 功能的。</p>

<p>```java
CustomTimerTask timerTask = new CustomTimerTask();</p>

<p>class CustomTimerTask implements Runnable {
    @Override
    public void run() {
        // scheduled tasks</p>

<pre><code>    // relaunch the task
    timerHandler.postDelayed(this, TIME_INTERVAL);
} } ```
</code></pre>

<h3 id="section-2">操作定时任务</h3>

<p>我们可以轻松的启动或者停止这个定时任务。</p>

<p><code>java
timerHandler.postDelayed(timerTask, TIME_INTERVAL); // launch the task
timerHandler.removeCallbacks(timerTask);	// stop it
</code></p>

<h2 id="section-3">参考</h2>

<p><a href="http://www.mopri.de/2010/timertask-bad-do-it-the-android-way-use-a-handler/">Timer(Task) = bad! Do it the Android way: Use a Handler :)</a></p>

<p><a href="http://docs.huihoo.com/android/2.1/resources/articles/timed-ui-updates.html">Updating the UI from a Timer</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（三）Controller & 异步图片加载]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/17/build-android-cache-module-3/"/>
    <updated>2014-06-17T15:48:38+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/17/build-android-cache-module-3</id>
    <content type="html"><![CDATA[<p>上一篇博客我们学习了缓存模块的实现， 缓存分做两份：<code>Memory Cache</code>和<code>File Cache</code>。方法也很简单，分别是：</p>

<ul>
  <li>存储文件</li>
  <li>按唯一key值索引文件</li>
  <li>清空缓存</li>
</ul>

<p>区别在于内存缓存读取优先，因为它读写的速度更快。但是考虑到内存限制，退而选用文件存储，分担内存缓存的压力。</p>

<p>原理非常简单，在第一课中已经详细分析了。那么要怎么才能将这个缓存模块与UI模块的显示关联起来呢？在这里我们需要一个控制器，掌管数据流向和读写，同时控制UI的显示。</p>

<p>那么这个控制器需要以下的元素：</p>

<ul>
  <li>内存缓存</li>
  <li>硬盘缓存</li>
  <li>异步任务处理</li>
  <li>控制UI显示</li>
</ul>

<p><code>java
//caches
private MemoryCache memoryCache;
private FileCache fileCache;
//Asynchronous task
private static AsyncImageLoader imageLoader;
</code></p>

<p><code>Memory Cache</code>和<code>File Cache</code>在上一课中有具体的实现，这里有一个异步的任务处理器—— <code>AsyncImageDownloader</code>，它用来在后台下载数据，完成下载后存储数据到缓存中，并更新UI的显示 。让我们来看看它是如何实现的：</p>

<p>```java
class AsyncImageDownloader extends AsyncTask&lt;Void, Void, Bitmap&gt;{
	private ImageView imageView;
	private String fileName;</p>

<pre><code>public AsyncImageDownloader(ImageView imageView, String fileName){
	this.imageView = imageView;
	this.fileName = fileName;
}

@Override
protected void onPreExecute() {
	super.onPreExecute();
	imageView.setImageResource(R.drawable.placeholder);
}

@Override
protected Bitmap doInBackground(Void... arg0) {
	String url = Utils.getRealUrlOfPicture(fileName);
	HttpResponse response = new HttpRetriever().requestGet(url, null);
	Log.i(TAG, "url: " + url);
	Log.i(TAG, "respone: " + response);
	InputStream in = null;
	try {
		if(response != null &amp;&amp; response.getEntity() != null)
			in = response.getEntity().getContent();
	} catch (IllegalStateException e) {
		e.printStackTrace();
		return null;
	} catch (IOException e) {
		e.printStackTrace();
		return null;
	}
	
	//TODO to be optimized: adjust the size of bitmap
	return BitmapFactory.decodeStream(in);
}

@Override
protected void onPostExecute(Bitmap result) {
	super.onPostExecute(result);
	if(result != null &amp;&amp; imageView != null)
		imageView.setImageBitmap(result);
	
	//TODO cache the bitmap both in sdcard &amp; memory
	memoryCache.put(fileName, result);// key is a unique token, value is the bitmap
	
	fileCache.put(fileName, result);
} } ```
</code></pre>

<p>可以看到这个类的构造函数需要两个参数，分别是文件名和对应要显示的<code>ImageView</code>，那么在任务开始的时候，可以为该<code>ImageView</code>设置未下载状态的图片，然后下载完成后更新UI。</p>

<blockquote>
  <p>注：需要提醒的是，这里的唯一key值，我使用的是文件名，因为我接收到的文件名是唯一的。猿媛们也可以根据自己的需求，设计自己的唯一key值算法。</p>
</blockquote>

<p>接下来，我们需要读用<code>key</code>值索引相应的<code>Bitmap</code>：</p>

<p>```java
public Bitmap getBitmap(String key){
	Bitmap bitmap = null;
	//1. search memory
	bitmap = memoryCache.get(key);</p>

<pre><code>//2. search sdcard
if(bitmap == null){
	File file = fileCache.getFile(key);
	if(file != null)
		bitmap = BitmapHelper.decodeFile(file, null);
}

return bitmap; } ``` 到这里，一个简单的缓存框架就搭建成功了。它简洁有效，但是非常单薄，似乎不够强大，需要你们根据自己的需求进行修改。另外它本来的目的就是用于演示，理解这个以后，我们再来看``Google``的``BitmapFun``。
</code></pre>

<p>不过，我将它应用在一个小项目中，性能还不错。对于小项目的需求，应该是够的。</p>

<p>最后，附上使用方法，以及整个类的代码。</p>

<h2 id="section">使用</h2>

<p><code>java
AsyncImageLoader imageLoader = AsyncImageLoader.getInstance(this);、
imageLoader.displayBitmap(imageView, fileName);
</code></p>

<h2 id="asyncimageloader">AsyncImageLoader</h2>

<p>```java
public class AsyncImageLoader {</p>

<pre><code>private static final String TAG = "AsyncImageLoader";

//caches
private MemoryCache memoryCache;
private FileCache fileCache;
//Asynchronous task
private static AsyncImageLoader imageLoader;

class AsyncImageDownloader extends AsyncTask&lt;Void, Void, Bitmap&gt;{
	private ImageView imageView;
	private String fileName;
	
	public AsyncImageDownloader(ImageView imageView, String fileName){
		this.imageView = imageView;
		this.fileName = fileName;
	}
	
	@Override
	protected void onPreExecute() {
		super.onPreExecute();
		imageView.setImageResource(R.drawable.placeholder);
	}
	
	@Override
	protected Bitmap doInBackground(Void... arg0) {
		String url = Utils.getRealUrlOfPicture(fileName);
		HttpResponse response = new HttpRetriever().requestGet(url, null);
		Log.i(TAG, "url: " + url);
		Log.i(TAG, "respone: " + response);
		InputStream in = null;
		try {
			if(response != null &amp;&amp; response.getEntity() != null)
				in = response.getEntity().getContent();
		} catch (IllegalStateException e) {
			e.printStackTrace();
			return null;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
		
		//TODO to be optimized: adjust the size of bitmap
		return BitmapFactory.decodeStream(in);
	}
	
	@Override
	protected void onPostExecute(Bitmap result) {
		super.onPostExecute(result);
		if(result != null &amp;&amp; imageView != null)
			imageView.setImageBitmap(result);
		
		//TODO cache the bitmap both in sdcard &amp; memory
		memoryCache.put(fileName, result);// key is a unique token, value is the bitmap
		
		fileCache.put(fileName, result);
	}
}

private AsyncImageLoader(Context context){
	this.memoryCache 		= 	new MemoryCache();
	this.fileCache			= 	new FileCache(context);
}

public static AsyncImageLoader getInstance(Context context){
	if(imageLoader == null)
		imageLoader = new AsyncImageLoader(context);
	
	return imageLoader;
}

public void displayBitmap(ImageView imageView, String fileName){
	//no pic for this item
	if(fileName == null || "".equals(fileName))
		return;
	
	Bitmap bitmap = getBitmap(fileName);
	//search in cache, if there is no such bitmap, launch downloads
	if(bitmap != null){
		imageView.setImageBitmap(bitmap);
	}
	else{
		Log.w(TAG, "Can't find the file you required.");
		new AsyncImageDownloader(imageView, fileName).execute();
	}
}

public Bitmap getBitmap(String key){
	Bitmap bitmap = null;
	//1. search memory
	bitmap = memoryCache.get(key);
	
	//2. search sdcard
	if(bitmap == null){
		File file = fileCache.getFile(key);
		if(file != null)
			bitmap = BitmapHelper.decodeFile(file, null);
	}
	
	return bitmap;
}

public void clearCache(){
	if(memoryCache != null)
		memoryCache.clear();
	if(fileCache != null)
		fileCache.clear();
} } ```
</code></pre>

<h2 id="section-1">源码</h2>

<p>附上源码，不过服务器的源码暂时还没有放出来，先看看客户端的吧。</p>

<p><a href="https://github.com/ryanhoo/SoftRead">https://github.com/ryanhoo/SoftRead</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（二）Memory Cache & File Cache]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/05/build-android-cache-module-2/"/>
    <updated>2014-06-05T23:34:36+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/05/build-android-cache-module-2</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#memory-cache">Memory Cache</a></li>
  <li><a href="#file-cache">File Cache</a></li>
</ul>

<p>上一篇博客我们讲到普通应用缓存Bitmap的实现分析，根据 MVC 的实现原理，我将这个简单的缓存实现单独写成一个模块，这样可以方便以后的使用，对于任意的需求，都属于一个可插拔式的功能。</p>

<p>之前提到，这个缓存模块主要有两个子部件：</p>

<h2 id="memory-cache">Memory Cache</h2>

<p>内存缓存的存取速度非常惊人，远远快于文件读取，如果没有内存限制，当然首选这种方式。遗憾的是我们有着<strong>16M</strong>的限制（当然大多数设备限制要高于 Android 官方说的这个数字），这也正是大 Bitmap容易引起 OOM 的原因。Memory Cache 将使用 <code>WeakHashMap</code> 作为缓存的中枢，当程序内存告急时，它会主动清理部分弱引用（因此，当引用指向为 null ，我们必须转向硬盘缓存读取数据，如果硬盘也没有，那还是重新下载吧）。</p>

<p>能力越大，责任越大？人家只是跑得快了点儿，总得让人家休息，我们一定不希望让内存成为第一位跑完马拉松的 Pheidippides ，一次以后就挂了吧？作为精打细算的猿媛，我们只能将有限的内存分配给 Memory Cache ，将更繁重的任务托付给任劳任怨的 SDCard 。</p>

<h2 id="file-cache">File Cache</h2>

<p>硬盘读取速度当然不如内存，但是为了珍惜宝贵的流量，不让你的用户在月底没有流量时嚎叫着要删掉你开发的“流量杀手”，最好是避免重复下载。在第一次下载以后，将数据保存在本地即可。</p>

<p>文件读写的技术并不是很新颖的技术，Java Core 那点儿就够你用了。不过要记得我们可是将Bitmap写入文件啊，怎么写入呢？不用着急，Android 的 Bitmap 本身就具备将数据写入 OutputStream 的能力。我将这些额外的方法写在一个帮助类中：BitmapHelper</p>

<p><code>java
public static boolean saveBitmap(File file, Bitmap bitmap){
	if(file == null || bitmap == null)
		return false;
	try {
		BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));
		return bitmap.compress(CompressFormat.JPEG, 100, out);
	} catch (FileNotFoundException e) {
		e.printStackTrace();
		return false;
	}
}
</code></p>

<p>最后附上Memory Cache和File Cache的具体代码，非常简单。</p>

<p>```java
public class MemoryCache {
	private static final String TAG = “MemoryCache”;</p>

<pre><code>//WeakReference Map: key=string, value=Bitmap
private WeakHashMap&lt;String, Bitmap&gt; cache = new WeakHashMap&lt;String, Bitmap&gt;();

/**
 * Search the memory cache by a unique key. 
 * @param key Should be unique. 
 * @return The Bitmap object in memory cache corresponding to specific key.
 * */
public Bitmap get(String key){
    if(key != null)
    	return cache.get(key);
    return null;
}

/**
 * Put a bitmap into cache with a unique key.
 * @param key Should be unique.
 * @param value A bitmap.
 * */
public void put(String key, Bitmap value){
	if(key != null &amp;&amp; !"".equals(key) &amp;&amp; value != null){
		cache.put(key, value);
		//Log.i(TAG, "cache bitmap: " + key);
		Log.d(TAG, "size of memory cache: " + cache.size());
	}
}

/**
 * clear the memory cache.
 * */
public void clear() {
    cache.clear();
} } ```
</code></pre>

<p>```java
public class FileCache {</p>

<pre><code>private static final String TAG = "MemoryCache";

private File cacheDir;	//the directory to save images

/**
 * Constructor
 * @param context The context related to this cache.
 * */
public FileCache(Context context) {
	// Find the directory to save cached images
	if (android.os.Environment.getExternalStorageState()
			.equals(android.os.Environment.MEDIA_MOUNTED))
		cacheDir = new File(
				android.os.Environment.getExternalStorageDirectory(),
				Config.CACHE_DIR);
	else
		cacheDir = context.getCacheDir();
	if (!cacheDir.exists())
		cacheDir.mkdirs();
	
	Log.d(TAG, "cache dir: " + cacheDir.getAbsolutePath());
}

/**
 * Search the specific image file with a unique key.
 * @param key Should be unique.
 * @return Returns the image file corresponding to the key.
 * */
public File getFile(String key) {
	File f = new File(cacheDir, key);
	if (f.exists()){
		Log.i(TAG, "the file you wanted exists " + f.getAbsolutePath());
		return f;
	}else{
		Log.w(TAG, "the file you wanted does not exists: " + f.getAbsolutePath());
	}

	return null;
}

/**
 * Put a bitmap into cache with a unique key.
 * @param key Should be unique.
 * @param value A bitmap.
 * */
public void put(String key, Bitmap value){
	File f = new File(cacheDir, key);
	if(!f.exists())
		try {
			f.createNewFile();
		} catch (IOException e) {
			e.printStackTrace();
		}
	//Use the util's function to save the bitmap.
	if(BitmapHelper.saveBitmap(f, value))
		Log.d(TAG, "Save file to sdcard successfully!");
	else
		Log.w(TAG, "Save file to sdcard failed!");
	
}

/**
 * Clear the cache directory on sdcard.
 * */
public void clear() {
	File[] files = cacheDir.listFiles();
	for (File f : files)
		f.delete();
} } ```
</code></pre>

<p>没什么难的地方，直接贴代码。下一篇博客我将讲解如何使用异步任务下载数据，以及使用Controller操作Model，控制View的显示。 </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（一）吐槽与原理分析]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/04/build-android-cache-module-1/"/>
    <updated>2014-06-04T22:32:52+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/04/build-android-cache-module-1</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">摘要</a></li>
  <li><a href="#section-1">前言</a></li>
  <li><a href="#section-2">自力更生，构建自己的缓存模块</a></li>
  <li><a href="#oom">如何解决OOM</a></li>
  <li><a href="#section-3">佛说引用，既非引用，是名引用。</a></li>
  <li><a href="#section-4">原理示意图</a></li>
  <li><a href="#section-5">参考资料</a></li>
</ul>

<h2 id="section">摘要</h2>

<p>在我翻译的 <a href="http://my.oschina.net/ryanhoo/blog?catalog=260281">Google 官方系列教程</a>中，Bitmap 系列由浅入深地介绍了如何正确的解码 Bitmap ，异步线程操作以及使用 Fragments 重用等技术，并且在最后给出了非常强大的独家秘笈：<code>BitmapFun</code> ，让猿媛们得以一窥究竟 Google 的攻城师们是如何高屋建瓴地秒杀 <strong>OOM</strong> 的。</p>

<h2 id="section-1">前言</h2>

<p>在下载到 <a href="http://vdisk.weibo.com/s/hNgFB">BitmapFun.rar</a> 这个神圣的压缩包以后，我是双手颤抖，似乎是打开上古秘藏一般，心情激动导致久久不能自已。我还记得那天上海下着小雨，我当时霍然起身，伫立在 23 楼的窗台，仰着头向江水对岸的东方明珠望去，似乎这样我郁积已久的眼泪就不能掉下来。说到这里，Ryan 又暗自抹了一把眼泪。短暂地忘记了过去的黑暗时光，那一个漫长的被 <strong>OOM</strong> 的淫威所折磨的盛夏。。。</p>

<p>最后在 Boss诧异的目光中，我回到办公桌，按捺着内心汹涌的情绪波动，然后小心翼翼的打开 BitmapFun.rar 。当那些在洪荒时代就活跃在Android平台的大师们书写的篇章呈现在我眼前时，我的表情与阿宝从师父手里得到 <strong>Dragon Scroll</strong> 时一般，永久的定格在了极度天真的期待与眼角一抽一抽的状态。</p>

<p>那些泛黄的代码在我看去，通篇只有一句话：<code>老子看不懂！</code></p>

<h2 id="section-2">自力更生，构建自己的缓存模块</h2>

<p>Google 的这个 demo 堪称详尽，考虑极其周详，自然是极好的。但是当原理被层层的“特殊情况”包装起来，原本简单的例子变得异常复杂，几个类之间的关系错综复杂，堪比吸血鬼日记几个帅哥美女之间的关系。要理解清楚每一句代码的含义，你一定要有理解 Matt 那人老珠黄的老娘和他和失落的好朋友 Taylor 搞在一起的觉悟。</p>

<p>好了，吐槽一下就收，千万不要怀疑 Google ，人家已经仁至义尽了。 BitmapFun 中在下载后将 Bitmap 缓存起来，缓存做了两份：<code>LruCache</code> 和 <code>DiskLruCache</code> ，分别是内存缓存和硬盘缓存。此外两个至关重要的类是：</p>

<p>```java
BitmapWorkerTask(ImageView imageView)</p>

<p>AsyncDrawable extends BitmapDrawable
    AsyncDrawable(Resources res, Bitmap bitmap,BitmapWorkerTask bitmapWorkerTask)  <br />
```</p>

<p><code>BitmapWorkerTask</code> 持有一个 <code>WeakReference&lt;ImageView&gt; imageViewReference</code> ，弱引用 <code>ImageView</code> ，用作异步处理加载图片的任务。
<code>AsyncDrawable</code> 巧妙的引用持有弱引用 <code>WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference</code> ，是 <code>BitmapDrawable</code> 的子类，这样就可以 <code>setImageBitmap(AsyncDrawable)</code>。</p>

<p>关系：<code>AsyncDrawable</code> 中弱引用 <code>BitmapWorkerTask</code> 。其实是图片引用 <code>ImageView</code> 的关系，而<code>ImageView.getDrawable</code> 又可以获得图片。这种高妙的思想不是正值得我们学习么？   </p>

<p>当然，这节课并不是讲解官方Demo的，在讲解它之前，我们先来学习一个更加简单的缓存实现方案，使用最简单的方式快速构建自己应用的缓存模块，有效避免 OOM 异常。它的难度非常小也很方便理解，可以在这个缓存实现的基础上，我们再去理解更加高妙的 BitmapFun 的缓存实现方案。</p>

<h2 id="oom">如何解决OOM</h2>

<p>Bitmap 之所以容易引起OOM异常，原因已经在 Bitmap 系列教程中说的明明白白。但是我们至少清楚一点：一个手机屏幕再大，合理尺寸的 Bitmap 也不至于耗空所有内存，那要怎么做才能避免 OOM 呢？</p>

<ul>
  <li>加载合理尺寸的 Bitmap </li>
  <li>避免反复解码、重复加载 Bitmap</li>
  <li>控制 Bitmap 的生命周期，合理回收</li>
</ul>

<p>此外网上也有不少歪门邪道，我个人认为是不可取的，使用这些简单粗暴的方法，后期会为你带来更大的麻烦：</p>

<ul>
  <li>减损图片质量（使用过高的 inSampleSize 值）</li>
  <li>使用 decodeStream （绕过 Java 层，直接调用 JNI ）</li>
  <li>强制增加heap size</li>
  <li>其他</li>
</ul>

<p>控制Bitmap的生命周期才是正解， BitmapFun 使用的 LruCache 是将它将最近被引用到的对象存储在一个强引用的 LinkedHashMap 中，并且在缓存超过了指定大小之后将最近不常使用的对象释放掉。</p>

<p>Memory Cache 的 Size 是受限的，因此加入 DiskLruCache ，虽然在访问速度上逊于 Memory Cache ，但是速度也是相当可观的。</p>

<p>借鉴 Google 的做法，我也将缓存做了两份，一份是 Memory Cache ，使用弱引用的 WeakHashMap 来控制 Bitmap 的生命周期，后面会有详细解释。另一份严格来说不能算是缓存，直接将文件存储在 SDCard 上，避免重复下载。</p>

<h2 id="section-3">佛说引用，既非引用，是名引用。</h2>

<p>关于引用，或许对于小菜鸟们不是很好理解（我碰到过太多 Java 都没学好来做 Android 的，基础很重要！）。我使用金刚经的著名三段论来解释它：<code>佛说XX，既非XX，是名XX。</code></p>

<p>这句话什么意思呢？比如佛说大米，既可以说它不是大米，只是名字叫做大米罢了。不会因为你为它改名叫做大麦而改变它的本质，你叫它做水，吃到嘴里的还是原来的味道。</p>

<p>关于引用，跟这个有着非常相似的共性。引用就相当于实际对象的名字，比如下面的例子：</p>

<p><code>java
Person p1 = new Person();
Person p2 = null;
p2 = p1;
p1 = null;
</code>
<code>new Person()</code>这个对象的名是 p1 ，而后你将名字改成了 p2 ，对象还是那个对象，不会因为你将 p1 的大名盖在 null 的头上而改变它的本质。以上的 p1 和 p2 都是引用，它们都不过是名。</p>

<blockquote>
  <p>在了解到引用的含义后，虚拟机会告诉你，被引用的对象处于可获得( reachable )状态，它是你的好管家，既然你要用它，它就不会回收它。（你想想如果你正在吃一只烤鸭，人家突然一把抢了过去扔垃圾桶了你什么感觉。）</p>
</blockquote>

<blockquote>
  <p>如果在上面的那段程序后面加上 <code>p2 = null</code>，Person 这个对象就没有任何引用指向它了，垃圾回收器会在不确定的时间进行回收。（你都把东西扔了，总不能不让人家收破烂吧？）</p>
</blockquote>

<blockquote>
  <p>如果你想继续持有这个对象的引用，希望可以继续访问，但是也允许垃圾回收器进行回收，该怎么办呢？（你想减肥，告诉你的好朋友说，如果察觉到你太胖了，就将你嘴里的烤鸭抢去扔了。如果你很饿，身材也不错，你要继续吃。）</p>
</blockquote>

<p>这个时候，我们需要借助 Java 提供的软/弱/虚引用。我们平时使用的如 p1 和 p2 这样的叫做强引用(Strong Reference)。要使垃圾回收器能在内存不够的时候，主动抢下你嘴里的烤鸭，进行回收，需要使用这些：</p>

<ul>
  <li>软引用：SoftReference</li>
  <li>弱引用：WeakReference</li>
  <li>虚引用：PhantomReference</li>
</ul>

<p>它们按照由强到弱的引用关系排列，虚引用相当于几乎没有引用。文艺青年常说的若即若离用来形容它再恰当不过了。</p>

<p>关于这三个引用的具体学习，详见我提供的参考资料。这里只是向你解释为什么使用弱引用可以起到防止 Bitmap 过多而导致内存紧张的作用。</p>

<p>在这里，由于我需要使用 Bitmap 和名字的 key-value 对应关系，我使用 Java 提供的 <code>WeakHashMap(String key, Bitmap value)</code> ，顾名思义，它用来保存 WeakReference ，并且确保每个 key 只对应一个值，在内存不够的时候，垃圾回收器会进行回收。当 key 值索引不到 Bitmap ，再进行其他的操作。</p>

<h2 id="section-4">原理示意图</h2>

<p>我将原理画成图，以便大家的理解。主体有三个，分别是 UI ，缓存模块和数据源。它们之间的关系如下：</p>

<p><img src="/images/blog/android/130726_4p9B_245415.png" alt="原理示意图" /></p>

<p>① UI：请求数据，使用唯一的 Key 值索引 Memory Cache 中的 Bitmap 。</p>

<p>② 内存缓存：缓存搜索，如果能找到 Key 值对应的 Bitmap ，则返回数据。否则执行第三步。</p>

<p>③ 硬盘存储：使用唯一 Key 值对应的文件名，检索 SDCard 上的文件。</p>

<p>④ 如果有对应文件，使用 BitmapFactory.decode* 方法，解码 Bitmap 并返回数据，同时将数据写入缓存。如果没有对应文件，执行第五步。</p>

<p>⑤ 下载图片：启动异步线程，从数据源下载数据(Web)。</p>

<p>⑥ 若下载成功，将数据同时写入硬盘和缓存，并将 Bitmap 显示在 UI 中。</p>

<p>总结：这节课除了吐槽，主要的还是原理分析。如果你有更好的缓存方案，欢迎提出。下节课将讲解具体的 Memory Cache 和 FileCache 如何实现。</p>

<h2 id="section-5">参考资料</h2>

<p>【1】<a href="http://vdisk.weibo.com/s/jtqjr">Thinking In Java 4th Chapter 17.12 Hoding References.pdf</a></p>

<p>【2】<a href="http://vdisk.weibo.com/s/jtqjr">李刚：突破程序员基本功的16课之Java的内存回收.pdf</a>  </p>

]]></content>
  </entry>
  
</feed>
