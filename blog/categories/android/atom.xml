<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Ryan Hoo]]></title>
  <link href="http://ryanhoo.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://ryanhoo.github.io/"/>
  <updated>2014-06-05T23:40:28+08:00</updated>
  <id>http://ryanhoo.github.io/</id>
  <author>
    <name><![CDATA[Ryan Hoo]]></name>
    <email><![CDATA[ryan.hoo.j@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（二）Memory Cache & File Cache]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/05/build-android-cache-module-2/"/>
    <updated>2014-06-05T23:34:36+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/05/build-android-cache-module-2</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#memory-cache">Memory Cache</a></li>
  <li><a href="#file-cache">File Cache</a></li>
</ul>

<p>上一篇博客我们讲到普通应用缓存Bitmap的实现分析，根据 MVC 的实现原理，我将这个简单的缓存实现单独写成一个模块，这样可以方便以后的使用，对于任意的需求，都属于一个可插拔式的功能。</p>

<p>之前提到，这个缓存模块主要有两个子部件：</p>

<h2 id="memory-cache">Memory Cache</h2>

<p>内存缓存的存取速度非常惊人，远远快于文件读取，如果没有内存限制，当然首选这种方式。遗憾的是我们有着<strong>16M</strong>的限制（当然大多数设备限制要高于 Android 官方说的这个数字），这也正是大 Bitmap容易引起 OOM 的原因。Memory Cache 将使用 <code>WeakHashMap</code> 作为缓存的中枢，当程序内存告急时，它会主动清理部分弱引用（因此，当引用指向为 null ，我们必须转向硬盘缓存读取数据，如果硬盘也没有，那还是重新下载吧）。</p>

<p>能力越大，责任越大？人家只是跑得快了点儿，总得让人家休息，我们一定不希望让内存成为第一位跑完马拉松的 Pheidippides ，一次以后就挂了吧？作为精打细算的猿媛，我们只能将有限的内存分配给 Memory Cache ，将更繁重的任务托付给任劳任怨的 SDCard 。</p>

<h2 id="file-cache">File Cache</h2>

<p>硬盘读取速度当然不如内存，但是为了珍惜宝贵的流量，不让你的用户在月底没有流量时嚎叫着要删掉你开发的“流量杀手”，最好是避免重复下载。在第一次下载以后，将数据保存在本地即可。</p>

<p>文件读写的技术并不是很新颖的技术，Java Core 那点儿就够你用了。不过要记得我们可是将Bitmap写入文件啊，怎么写入呢？不用着急，Android 的 Bitmap 本身就具备将数据写入 OutputStream 的能力。我将这些额外的方法写在一个帮助类中：BitmapHelper</p>

<p><code>java
public static boolean saveBitmap(File file, Bitmap bitmap){
	if(file == null || bitmap == null)
		return false;
	try {
		BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));
		return bitmap.compress(CompressFormat.JPEG, 100, out);
	} catch (FileNotFoundException e) {
		e.printStackTrace();
		return false;
	}
}
</code></p>

<p>最后附上Memory Cache和File Cache的具体代码，非常简单。</p>

<p>```java
public class MemoryCache {
	private static final String TAG = “MemoryCache”;</p>

<pre><code>//WeakReference Map: key=string, value=Bitmap
private WeakHashMap&lt;String, Bitmap&gt; cache = new WeakHashMap&lt;String, Bitmap&gt;();

/**
 * Search the memory cache by a unique key. 
 * @param key Should be unique. 
 * @return The Bitmap object in memory cache corresponding to specific key.
 * */
public Bitmap get(String key){
    if(key != null)
    	return cache.get(key);
    return null;
}

/**
 * Put a bitmap into cache with a unique key.
 * @param key Should be unique.
 * @param value A bitmap.
 * */
public void put(String key, Bitmap value){
	if(key != null &amp;&amp; !"".equals(key) &amp;&amp; value != null){
		cache.put(key, value);
		//Log.i(TAG, "cache bitmap: " + key);
		Log.d(TAG, "size of memory cache: " + cache.size());
	}
}

/**
 * clear the memory cache.
 * */
public void clear() {
    cache.clear();
} } ```
</code></pre>

<p>```java
public class FileCache {</p>

<pre><code>private static final String TAG = "MemoryCache";

private File cacheDir;	//the directory to save images

/**
 * Constructor
 * @param context The context related to this cache.
 * */
public FileCache(Context context) {
	// Find the directory to save cached images
	if (android.os.Environment.getExternalStorageState()
			.equals(android.os.Environment.MEDIA_MOUNTED))
		cacheDir = new File(
				android.os.Environment.getExternalStorageDirectory(),
				Config.CACHE_DIR);
	else
		cacheDir = context.getCacheDir();
	if (!cacheDir.exists())
		cacheDir.mkdirs();
	
	Log.d(TAG, "cache dir: " + cacheDir.getAbsolutePath());
}

/**
 * Search the specific image file with a unique key.
 * @param key Should be unique.
 * @return Returns the image file corresponding to the key.
 * */
public File getFile(String key) {
	File f = new File(cacheDir, key);
	if (f.exists()){
		Log.i(TAG, "the file you wanted exists " + f.getAbsolutePath());
		return f;
	}else{
		Log.w(TAG, "the file you wanted does not exists: " + f.getAbsolutePath());
	}

	return null;
}

/**
 * Put a bitmap into cache with a unique key.
 * @param key Should be unique.
 * @param value A bitmap.
 * */
public void put(String key, Bitmap value){
	File f = new File(cacheDir, key);
	if(!f.exists())
		try {
			f.createNewFile();
		} catch (IOException e) {
			e.printStackTrace();
		}
	//Use the util's function to save the bitmap.
	if(BitmapHelper.saveBitmap(f, value))
		Log.d(TAG, "Save file to sdcard successfully!");
	else
		Log.w(TAG, "Save file to sdcard failed!");
	
}

/**
 * Clear the cache directory on sdcard.
 * */
public void clear() {
	File[] files = cacheDir.listFiles();
	for (File f : files)
		f.delete();
} } ```
</code></pre>

<p>没什么难的地方，直接贴代码。下节课我讲讲解如何使用异步任务下载数据，以及使用Controller操作Model，控制View的显示。 </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（一）吐槽与原理分析]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/04/build-android-cache-module-1/"/>
    <updated>2014-06-04T22:32:52+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/04/build-android-cache-module-1</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">摘要</a></li>
  <li><a href="#section-1">前言</a></li>
  <li><a href="#section-2">自力更生，构建自己的缓存模块</a></li>
  <li><a href="#oom">如何解决OOM</a></li>
  <li><a href="#section-3">佛说引用，既非引用，是名引用。</a></li>
  <li><a href="#section-4">原理示意图</a></li>
  <li><a href="#section-5">参考资料</a></li>
</ul>

<h2 id="section">摘要</h2>

<p>在我翻译的 <a href="http://my.oschina.net/ryanhoo/blog?catalog=260281">Google 官方系列教程</a>中，Bitmap 系列由浅入深地介绍了如何正确的解码 Bitmap ，异步线程操作以及使用 Fragments 重用等技术，并且在最后给出了非常强大的独家秘笈：<code>BitmapFun</code> ，让猿媛们得以一窥究竟 Google 的攻城师们是如何高屋建瓴地秒杀 <strong>OOM</strong> 的。</p>

<h2 id="section-1">前言</h2>

<p>在下载到 <a href="http://vdisk.weibo.com/s/hNgFB">BitmapFun.rar</a> 这个神圣的压缩包以后，我是双手颤抖，似乎是打开上古秘藏一般，心情激动导致久久不能自已。我还记得那天上海下着小雨，我当时霍然起身，伫立在 23 楼的窗台，仰着头向江水对岸的东方明珠望去，似乎这样我郁积已久的眼泪就不能掉下来。说到这里，Ryan 又暗自抹了一把眼泪。短暂地忘记了过去的黑暗时光，那一个漫长的被 <strong>OOM</strong> 的淫威所折磨的盛夏。。。</p>

<p>最后在 Boss诧异的目光中，我回到办公桌，按捺着内心汹涌的情绪波动，然后小心翼翼的打开 BitmapFun.rar 。当那些在洪荒时代就活跃在Android平台的大师们书写的篇章呈现在我眼前时，我的表情与阿宝从师父手里得到 <strong>Dragon Scroll</strong> 时一般，永久的定格在了极度天真的期待与眼角一抽一抽的状态。</p>

<p>那些泛黄的代码在我看去，通篇只有一句话：<code>老子看不懂！</code></p>

<h2 id="section-2">自力更生，构建自己的缓存模块</h2>

<p>Google 的这个 demo 堪称详尽，考虑极其周详，自然是极好的。但是当原理被层层的“特殊情况”包装起来，原本简单的例子变得异常复杂，几个类之间的关系错综复杂，堪比吸血鬼日记几个帅哥美女之间的关系。要理解清楚每一句代码的含义，你一定要有理解 Matt 那人老珠黄的老娘和他和失落的好朋友 Taylor 搞在一起的觉悟。</p>

<p>好了，吐槽一下就收，千万不要怀疑 Google ，人家已经仁至义尽了。 BitmapFun 中在下载后将 Bitmap 缓存起来，缓存做了两份：<code>LruCache</code> 和 <code>DiskLruCache</code> ，分别是内存缓存和硬盘缓存。此外两个至关重要的类是：</p>

<p>```java
BitmapWorkerTask(ImageView imageView)</p>

<p>AsyncDrawable extends BitmapDrawable
    AsyncDrawable(Resources res, Bitmap bitmap,BitmapWorkerTask bitmapWorkerTask)  <br />
```</p>

<p><code>BitmapWorkerTask</code> 持有一个 <code>WeakReference&lt;ImageView&gt; imageViewReference</code> ，弱引用 <code>ImageView</code> ，用作异步处理加载图片的任务。
<code>AsyncDrawable</code> 巧妙的引用持有弱引用 <code>WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference</code> ，是 <code>BitmapDrawable</code> 的子类，这样就可以 <code>setImageBitmap(AsyncDrawable)</code>。</p>

<p>关系：<code>AsyncDrawable</code> 中弱引用 <code>BitmapWorkerTask</code> 。其实是图片引用 <code>ImageView</code> 的关系，而<code>ImageView.getDrawable</code> 又可以获得图片。这种高妙的思想不是正值得我们学习么？   </p>

<p>当然，这节课并不是讲解官方Demo的，在讲解它之前，我们先来学习一个更加简单的缓存实现方案，使用最简单的方式快速构建自己应用的缓存模块，有效避免 OOM 异常。它的难度非常小也很方便理解，可以在这个缓存实现的基础上，我们再去理解更加高妙的 BitmapFun 的缓存实现方案。</p>

<h2 id="oom">如何解决OOM</h2>

<p>Bitmap 之所以容易引起OOM异常，原因已经在 Bitmap 系列教程中说的明明白白。但是我们至少清楚一点：一个手机屏幕再大，合理尺寸的 Bitmap 也不至于耗空所有内存，那要怎么做才能避免 OOM 呢？</p>

<ul>
  <li>加载合理尺寸的 Bitmap </li>
  <li>避免反复解码、重复加载 Bitmap</li>
  <li>控制 Bitmap 的生命周期，合理回收</li>
</ul>

<p>此外网上也有不少歪门邪道，我个人认为是不可取的，使用这些简单粗暴的方法，后期会为你带来更大的麻烦：</p>

<ul>
  <li>减损图片质量（使用过高的 inSampleSize 值）</li>
  <li>使用 decodeStream （绕过 Java 层，直接调用 JNI ）</li>
  <li>强制增加heap size</li>
  <li>其他</li>
</ul>

<p>控制Bitmap的生命周期才是正解， BitmapFun 使用的 LruCache 是将它将最近被引用到的对象存储在一个强引用的 LinkedHashMap 中，并且在缓存超过了指定大小之后将最近不常使用的对象释放掉。</p>

<p>Memory Cache 的 Size 是受限的，因此加入 DiskLruCache ，虽然在访问速度上逊于 Memory Cache ，但是速度也是相当可观的。</p>

<p>借鉴 Google 的做法，我也将缓存做了两份，一份是 Memory Cache ，使用弱引用的 WeakHashMap 来控制 Bitmap 的生命周期，后面会有详细解释。另一份严格来说不能算是缓存，直接将文件存储在 SDCard 上，避免重复下载。</p>

<h2 id="section-3">佛说引用，既非引用，是名引用。</h2>

<p>关于引用，或许对于小菜鸟们不是很好理解（我碰到过太多 Java 都没学好来做 Android 的，基础很重要！）。我使用金刚经的著名三段论来解释它：<code>佛说XX，既非XX，是名XX。</code></p>

<p>这句话什么意思呢？比如佛说大米，既可以说它不是大米，只是名字叫做大米罢了。不会因为你为它改名叫做大麦而改变它的本质，你叫它做水，吃到嘴里的还是原来的味道。</p>

<p>关于引用，跟这个有着非常相似的共性。引用就相当于实际对象的名字，比如下面的例子：</p>

<p><code>java
Person p1 = new Person();
Person p2 = null;
p2 = p1;
p1 = null;
</code>
<code>new Person()</code>这个对象的名是 p1 ，而后你将名字改成了 p2 ，对象还是那个对象，不会因为你将 p1 的大名盖在 null 的头上而改变它的本质。以上的 p1 和 p2 都是引用，它们都不过是名。</p>

<blockquote>
  <p>在了解到引用的含义后，虚拟机会告诉你，被引用的对象处于可获得( reachable )状态，它是你的好管家，既然你要用它，它就不会回收它。（你想想如果你正在吃一只烤鸭，人家突然一把抢了过去扔垃圾桶了你什么感觉。）</p>
</blockquote>

<blockquote>
  <p>如果在上面的那段程序后面加上 <code>p2 = null</code>，Person 这个对象就没有任何引用指向它了，垃圾回收器会在不确定的时间进行回收。（你都把东西扔了，总不能不让人家收破烂吧？）</p>
</blockquote>

<blockquote>
  <p>如果你想继续持有这个对象的引用，希望可以继续访问，但是也允许垃圾回收器进行回收，该怎么办呢？（你想减肥，告诉你的好朋友说，如果察觉到你太胖了，就将你嘴里的烤鸭抢去扔了。如果你很饿，身材也不错，你要继续吃。）</p>
</blockquote>

<p>这个时候，我们需要借助 Java 提供的软/弱/虚引用。我们平时使用的如 p1 和 p2 这样的叫做强引用(Strong Reference)。要使垃圾回收器能在内存不够的时候，主动抢下你嘴里的烤鸭，进行回收，需要使用这些：</p>

<ul>
  <li>软引用：SoftReference</li>
  <li>弱引用：WeakReference</li>
  <li>虚引用：PhantomReference</li>
</ul>

<p>它们按照由强到弱的引用关系排列，虚引用相当于几乎没有引用。文艺青年常说的若即若离用来形容它再恰当不过了。</p>

<p>关于这三个引用的具体学习，详见我提供的参考资料。这里只是向你解释为什么使用弱引用可以起到防止 Bitmap 过多而导致内存紧张的作用。</p>

<p>在这里，由于我需要使用 Bitmap 和名字的 key-value 对应关系，我使用 Java 提供的 <code>WeakHashMap(String key, Bitmap value)</code> ，顾名思义，它用来保存 WeakReference ，并且确保每个 key 只对应一个值，在内存不够的时候，垃圾回收器会进行回收。当 key 值索引不到 Bitmap ，再进行其他的操作。</p>

<h2 id="section-4">原理示意图</h2>

<p>我将原理画成图，以便大家的理解。主体有三个，分别是 UI ，缓存模块和数据源。它们之间的关系如下：</p>

<p><img src="images/blog/android/130726_4p9B_245415.png" alt="原理示意图" /></p>

<p>① UI：请求数据，使用唯一的 Key 值索引 Memory Cache 中的 Bitmap 。</p>

<p>② 内存缓存：缓存搜索，如果能找到 Key 值对应的 Bitmap ，则返回数据。否则执行第三步。</p>

<p>③ 硬盘存储：使用唯一 Key 值对应的文件名，检索 SDCard 上的文件。</p>

<p>④ 如果有对应文件，使用 BitmapFactory.decode* 方法，解码 Bitmap 并返回数据，同时将数据写入缓存。如果没有对应文件，执行第五步。</p>

<p>⑤ 下载图片：启动异步线程，从数据源下载数据(Web)。</p>

<p>⑥ 若下载成功，将数据同时写入硬盘和缓存，并将 Bitmap 显示在 UI 中。</p>

<p>总结：这节课除了吐槽，主要的还是原理分析。如果你有更好的缓存方案，欢迎提出。下节课将讲解具体的 Memory Cache 和 FileCache 如何实现。</p>

<h2 id="section-5">参考资料</h2>

<p>【1】<a href="http://vdisk.weibo.com/s/jtqjr">Thinking In Java 4th Chapter 17.12 Hoding References.pdf</a></p>

<p>【2】<a href="http://vdisk.weibo.com/s/jtqjr">李刚：突破程序员基本功的16课之Java的内存回收.pdf</a>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android大图片裁剪终极解决方案（下：拍照截图）]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-3/"/>
    <updated>2014-06-03T22:34:51+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-3</id>
    <content type="html"><![CDATA[<p>上一篇博客中，我们学习到了如何使用Android相册截图。在这篇博客中，我将向大家展示如何拍照截图。</p>

<p>拍照截图有点儿特殊，要知道，现在的Android智能手机的摄像头都是几百万的像素，拍出来的图片都是非常大的。因此，我们不能像对待相册截图一样使用Bitmap小图，无论大图小图都统一使用Uri进行操作。</p>

<h4 id="uri">一、首先准备好需要使用到的Uri：</h4>

<p><code>java
private static final String IMAGE_FILE_LOCATION = "file:///sdcard/temp.jpg";//temp file
Uri imageUri = Uri.parse(IMAGE_FILE_LOCATION);//The Uri to store the big bitmap
</code></p>

<h4 id="mediastoreactionimagecapturecamera">二、使用MediaStore.ACTION_IMAGE_CAPTURE可以轻松调用Camera程序进行拍照：</h4>

<p><code>java
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//action is capture
intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
startActivityForResult(intent, TAKE_BIG_PICTURE);//or TAKE_SMALL_PICTURE
</code></p>

<h4 id="onactivityresulturiuri">三、接下来就可以在 onActivityResult中拿到返回的数据（Uri），并将Uri传递给截图的程序。</h4>

<p>```java
switch (requestCode) {
case TAKE_BIG_PICTURE:
	Log.d(TAG, “TAKE_BIG_PICTURE: data = “ + data);//it seems to be null
	//TODO sent to crop
	cropImageUri(imageUri, 800, 400, CROP_BIG_PICTURE);</p>

<pre><code>break; case TAKE_SMALL_PICTURE:
Log.i(TAG, "TAKE_SMALL_PICTURE: data = " + data);
//TODO sent to crop 
cropImageUri(imageUri, 300, 150, CROP_SMALL_PICTURE);

break; } ```
</code></pre>

<p>可以看到，无论是拍大图片还是小图片，都是使用的Uri，只是尺寸不同而已。我们将这个操作封装在一个方法里面。</p>

<p><code>java
private void cropImageUri(Uri uri, int outputX, int outputY, int requestCode){
	Intent intent = new Intent("com.android.camera.action.CROP");
	intent.setDataAndType(uri, "image/*");
	intent.putExtra("crop", "true");
	intent.putExtra("aspectX", 2);
	intent.putExtra("aspectY", 1);
	intent.putExtra("outputX", outputX);
	intent.putExtra("outputY", outputY);
	intent.putExtra("scale", true);
	intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
	intent.putExtra("return-data", false);
	intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
	intent.putExtra("noFaceDetection", true); // no face detection
	startActivityForResult(intent, requestCode);
}
</code></p>

<h4 id="section">四、最后一步，我们已经将数据传入裁剪图片程序，接下来要做的就是处理返回的数据了：</h4>

<p><code>java
switch (requestCode) {
case CROP_BIG_PICTURE://from crop_big_picture
	Log.d(TAG, "CROP_BIG_PICTURE: data = " + data);//it seems to be null
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);
		imageView.setImageBitmap(bitmap);
	}
	break;
case CROP_SMALL_PICTURE:
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);
		imageView.setImageBitmap(bitmap);
	}else{
		Log.e(TAG, "CROP_SMALL_PICTURE: data = " + data);
	}
	break;
default:
	break;
}
</code></p>

<h4 id="section-1">效果图：</h4>

<p><img src="images/blog/android/184229_tlMc_245415.gif" alt="截图演示" /></p>

<blockquote>
  <p>代码托管于GitHub，会不定期更新：<a href="https://github.com/ryanhoo/PhotoCropper">https://github.com/ryanhoo/PhotoCropper</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android大图片裁剪终极解决方案（中：从相册截图）]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-2/"/>
    <updated>2014-06-03T22:21:35+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-2</id>
    <content type="html"><![CDATA[<p>在这篇博客中，我将向大家展示如何从相册截图。</p>

<p>上一篇博客中，我就拍照截图这一需求进行了详细的分析，试图让大家了解Android本身的限制，以及我们应当采取的实现方案。</p>

<p>根据我们的分析与总结，图片的来源有拍照和相册，而可采取的操作有</p>

<ul>
  <li>使用Bitmap并返回数据</li>
  <li>使用Uri不返回数据</li>
</ul>

<p>前面我们了解到，使用Bitmap有可能会导致图片过大，而不能返回实际大小的图片，我将采用大图Uri，小图Bitmap的数据存储方式。</p>

<p>我们将要使用到URI来保存拍照后的图片：</p>

<p><code>java
static final String IMAGE_FILE_LOCATION = "file:///sdcard/temp.jpg";//temp file
Uri imageUri = Uri.parse(IMAGE_FILE_LOCATION);//The Uri to store the big bitmap
</code></p>

<p>不难知道，我们从相册选取图片的<strong>Action</strong>为<code>Intent.ACTION_GET_CONTENT</code>。</p>

<p>根据我们上一篇博客的分析，我准备好了两个实例的Intent。</p>

<h4 id="section">一、从相册截大图：</h4>

<p><code>java
Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
intent.setType("image/*");
intent.putExtra("crop", "true");
intent.putExtra("aspectX", 2);
intent.putExtra("aspectY", 1);
intent.putExtra("outputX", 600);
intent.putExtra("outputY", 300);
intent.putExtra("scale", true);
intent.putExtra("return-data", false);
intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
intent.putExtra("noFaceDetection", true); // no face detection
startActivityForResult(intent, CHOOSE_BIG_PICTURE);
</code></p>

<h4 id="section-1">二、从相册截小图</h4>

<p><code>java
Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
intent.setType("image/*");
intent.putExtra("crop", "true");
intent.putExtra("aspectX", 2);
intent.putExtra("aspectY", 1);
intent.putExtra("outputX", 200);
intent.putExtra("outputY", 100);
intent.putExtra("scale", true);
intent.putExtra("return-data", true);
intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
intent.putExtra("noFaceDetection", true); // no face detection
startActivityForResult(intent, CHOOSE_SMALL_PICTURE);
</code></p>

<h4 id="onactivityresult">三、对应的onActivityResult可以这样处理返回的数据</h4>

<p><code>java
switch (requestCode) {
case CHOOSE_BIG_PICTURE:
	Log.d(TAG, "CHOOSE_BIG_PICTURE: data = " + data);//it seems to be null
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);//decode bitmap
		imageView.setImageBitmap(bitmap);
	}
break;
case CHOOSE_SMALL_PICTURE:
	if(data != null){
		Bitmap bitmap = data.getParcelableExtra("data");
		imageView.setImageBitmap(bitmap);
	}else{
		Log.e(TAG, "CHOOSE_SMALL_PICTURE: data = " + data);
	}
break;
}
</code></p>

<h4 id="section-2">效果图</h4>

<p><img src="/images/blog/android/183645_yuLJ_245415.gif" alt="大图" /></p>

<p><img src="/images/blog/android/183707_DnNy_245415.gif" alt="小图" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android大图片裁剪终极解决方案（上：原理分析）]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/05/26/the-ultimate-approach-to-crop-photos-on-android-1/"/>
    <updated>2014-05-26T17:37:42+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/05/26/the-ultimate-approach-to-crop-photos-on-android-1</id>
    <content type="html"><![CDATA[
<p>约几个月前，我正为公司的APP在Android手机上实现拍照截图而烦恼不已。</p>

<p>上网搜索，确实有不少的例子，大多都是抄来抄去，而且水平多半处于demo的样子，可以用来讲解知识点，但是一碰到实际项目，就漏洞百出。</p>

<p>当时我用大众化的解决方案，暂时性的做了一个拍照截图的功能，似乎看起来很不错。可是问题随之而来，我用的是小米手机，在别的手机上都运行正常，在小米这里却总是碰钉子。虽然我是个理性的米粉，但是也暗地里把小米的工程师问候了个遍。真是惭愧！</p>

<p>翻文档也找不出个答案来，我一直对<strong>com.android.camera.action.CROP</strong>持有大大的疑问，它是从哪里来，它能干什么，它接收处理什么类型的数据？Google对此却讳莫如深，在官方文档中只有Intent中有只言片语言及，却不甚详尽。</p>

<p>随着项目的驱动，我不能抱着不了解原理就不往前走的心态，唯一要做的，是解决问题。最后在德问上找到一条解决方案，说是哪怕是大米也没问题。当时乐呵呵将代码改了改，确实在所有的手机上跑起来了，一时如释重负，对这个的疑问也抛诸脑后了。</p>

<p>直到月前，BOSS要求将拍照上传到服务器的图片分辨率加倍。OK，加倍简单，增加<code>outputX</code>以及<code>outputY</code>不就得了？</p>

<p><code>java
intent.putExtra("outputX", outputX);
intent.putExtra("outputY", outputY);
</code></p>

<p>这一增加，吓了我一跳。BOSS的手机拍到的照片几乎就是个缩略图，但是被我问候了全体工程师的小米在这个时候就体现出国产神机的范儿了，小米上的尺寸一切正常。这个为什么呢？我大致了解原因，却不知道如何解决。</p>

<p>在Android中，Intent触发Camera程序，拍好照片后，将会返回数据，但是考虑到内存问题，Camera不会将全尺寸的图像返回给调用的Activity，一般情况下，有可能返回的是缩略图，比如<strong>120*160px</strong>。</p>

<p>这是为什么呢？这不是一个Bug，而是经过精心设计的，却对开发者不透明。</p>

<p>以我的小米手机为例，摄像头800W像素，根据我目前设置拍出来的图片尺寸为<strong>3200*2400px</strong>。有人说，那就返回呗，大不了耗1-2M的内存，不错，这个尺寸的图片确实只有1.8M左右的大小。但是你想不到的是，这个尺寸对应的Bitmap会耗光你应用程序的所有内存。Android出于安全性考虑，只会给你一个寒碜的缩略图。</p>

<p>在Android2.3中，默认的Bitmap为32位，类型是<code>ARGB_8888</code>，也就意味着一个像素点占用4个字节的内存。我们来做一个简单的计算题：</p>

<p><code>3200*2400*4 bytes =   30M</code></p>

<p>如此惊人的数字！哪怕你愿意为一张生命周期超不过10s的位图愿意耗费这么巨大的内存，Android也不会答应的。</p>

<blockquote>
  <p>Mobile devices typically have constrained system resources. 
Android devices can have as little as 16MB of memory available to a single application.</p>
</blockquote>

<p>这是Android Doc的原文，虽然不同手机系统的厂商可能围绕16M这个数字有微微的上调，但是这30M，一般的手机还真挥霍不起。也只有小米这种牛机，内存堪比个人PC，本着土财主般挥金如土的霸气才能做到。</p>

<p>OK，说了这么多，无非是吐吐苦水，爆爆个人经历而已，实际的解决方案在哪里呢？</p>

<p>我也是Google到的，话说一般百度不了的问题，那就<code>Google</code>或者直接<code>StackOverFlow</code>，只不过得看英文罢了。</p>

<p>最后翻来覆去，我在国外的一个Android团队的博客中找到了相应的方案，印证了我的猜想同时也给出了实际的代码。</p>

<p>我将这篇文章翻译成了中文，作为本博客的基础，建议详细看看。</p>

<p><a href="http://my.oschina.net/ryanhoo/blog/86843">【译】如何使用Android MediaStore裁剪大图片</a></p>

<p>这篇博客了不起的地方在于解决了Android对返回图片的大小限制，并且详细解释了裁剪图片的<code>Intent</code>附加数据的具体含义。我只是站在巨人的肩膀上，改善方案，适应更广泛需求而已。</p>

<p>拿图说事儿：</p>

<p><img src="/images/blog/android/144805_wCcI_245415.png" alt="Intent Options" /></p>

<p><code>Intent("com.android.camera.action.CROP")</code>对应的所有可选数据都一目了然。在了解上面个个选项的含义之后，我们将目光着眼于三个极为重要的选项：</p>

<ul>
  <li>data</li>
  <li>MediaStore.EXTRA_OUTPUT</li>
  <li>return-data</li>
</ul>

<p><code>data和MediaStore.EXTRA_OUTPUT</code>都是可选的传入数据选项，你可以选择设置data为Bitmap，或者将相应的数据与URI关联起来，你也可以选择是否返回数据（return-data: true）。</p>

<p>为什么还有不用返回数据的选项？如果对URI足够了解的话，应该知道URI与File相似，你所有的操作如裁剪将数据都保存在了URI中，你已经持有了相应的URI，也就无需多此一举，再返回Bitmap了。</p>

<p>前面已经说到，可以设置data为Bitmap，但是这种操作的限制在于，你的Bitmap不能太大。因此，我们前进的思路似乎明确了：截大图用URI，小图用Bitmap。</p>

<p>我将这个思路整理成一张图片：</p>

<p><img src="/images/blog/android/151831_7gRC_245415.png" alt="idea" /></p>

<p>这篇主要让大家了解需求的来源，以及如何去思考分析并解决问题。下一篇博客将介绍具体的操作。</p>

]]></content>
  </entry>
  
</feed>
