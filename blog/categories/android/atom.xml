<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Ryan Hoo]]></title>
  <link href="http://ryanhoo.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://ryanhoo.github.io/"/>
  <updated>2014-06-26T21:39:31+08:00</updated>
  <id>http://ryanhoo.github.io/</id>
  <author>
    <name><![CDATA[Ryan Hoo]]></name>
    <email><![CDATA[ryan.hoo.j@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Timer(Task) ？ Not in Android ！]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/26/do-not-use-timer-in-android/"/>
    <updated>2014-06-26T20:55:04+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/26/do-not-use-timer-in-android</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">前言</a></li>
  <li><a href="#section-1">解决方案</a>    <ul>
      <li><a href="#timer">Timer</a></li>
      <li><a href="#timertask">TimerTask</a></li>
      <li><a href="#section-2">操作定时任务</a></li>
    </ul>
  </li>
  <li><a href="#section-3">参考</a></li>
</ul>

<h2 id="section">前言</h2>

<p>我们对于 <code>java.util.Timer(Task)</code> 这两个类可谓不陌生，定时任务处处可见它俩如胶似漆的背影。只是，有心人必定会发现在 <strong>Android UI</strong> 中使用，它们带来的麻烦远远大于便利。</p>

<p>我在多个场景碰到过这个问题，往往是忍气吞声，不厌其烦的处理着它们的『身后事』，还得提防它们时而罢工的臭毛病。</p>

<h2 id="section-1">解决方案</h2>

<p>其实使用 Android 自己的 <a href="https://developer.android.com/reference/android/os/Handler.html">Handler</a> 就可以解决这个问题。而且有如下优点：</p>

<ul>
  <li>重用</li>
</ul>

<p>可以很好的重用我们的定时任务，而以往使用 <code>Timer(Task)</code> ，我们不得不销毁，再 <code>new Timer(Task)</code>，不得不说是一种很粗鲁的方式。</p>

<ul>
  <li>可控性</li>
</ul>

<p><code>Timer(Task)</code> 的组合更像是离弦之箭，不能收发自如。而使用 <code>Handler</code> 的方式，调用 <code>removeCallbacks</code> 即可轻松暂停或者重置任务。</p>

<h3 id="timer">Timer</h3>

<p>使用 <a href="https://developer.android.com/reference/android/os/Handler.html">Handler</a> 来替代 <a href="https://developer.android.com/reference/java/util/Timer.html">Timer</a>。</p>

<p><code>java
Handler timerHandler = new Handler()
</code></p>

<h3 id="timertask">TimerTask</h3>

<p>简单可重用的 <code>Runnable</code> ，用来执行定时任务，但是这里是用的比较 <strong>Hack</strong> 的方式来实现循环的 Timer 功能的。</p>

<p>```java
CustomTimerTask timerTask = new CustomTimerTask();</p>

<p>class CustomTimerTask implements Runnable {
    @Override
    public void run() {
        // scheduled tasks</p>

<pre><code>    // relaunch the task
    timerHandler.postDelayed(this, TIME_INTERVAL);
} } ```
</code></pre>

<h3 id="section-2">操作定时任务</h3>

<p>我们可以轻松的启动或者停止这个定时任务。</p>

<p><code>java
timerHandler.postDelayed(timerTask, TIME_INTERVAL); // launch the task
timerHandler.removeCallbacks(timerTask);	// stop it
</code></p>

<h2 id="section-3">参考</h2>

<p><a href="http://www.mopri.de/2010/timertask-bad-do-it-the-android-way-use-a-handler/">Timer(Task) = bad! Do it the Android way: Use a Handler :)</a></p>

<p><a href="http://docs.huihoo.com/android/2.1/resources/articles/timed-ui-updates.html">Updating the UI from a Timer</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（三）Controller & 异步图片加载]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/17/build-android-cache-module-3/"/>
    <updated>2014-06-17T15:48:38+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/17/build-android-cache-module-3</id>
    <content type="html"><![CDATA[<p>上一篇博客我们学习了缓存模块的实现， 缓存分做两份：<code>Memory Cache</code>和<code>File Cache</code>。方法也很简单，分别是：</p>

<ul>
  <li>存储文件</li>
  <li>按唯一key值索引文件</li>
  <li>清空缓存</li>
</ul>

<p>区别在于内存缓存读取优先，因为它读写的速度更快。但是考虑到内存限制，退而选用文件存储，分担内存缓存的压力。</p>

<p>原理非常简单，在第一课中已经详细分析了。那么要怎么才能将这个缓存模块与UI模块的显示关联起来呢？在这里我们需要一个控制器，掌管数据流向和读写，同时控制UI的显示。</p>

<p>那么这个控制器需要以下的元素：</p>

<ul>
  <li>内存缓存</li>
  <li>硬盘缓存</li>
  <li>异步任务处理</li>
  <li>控制UI显示</li>
</ul>

<p><code>java
//caches
private MemoryCache memoryCache;
private FileCache fileCache;
//Asynchronous task
private static AsyncImageLoader imageLoader;
</code></p>

<p><code>Memory Cache</code>和<code>File Cache</code>在上一课中有具体的实现，这里有一个异步的任务处理器—— <code>AsyncImageDownloader</code>，它用来在后台下载数据，完成下载后存储数据到缓存中，并更新UI的显示 。让我们来看看它是如何实现的：</p>

<p>```java
class AsyncImageDownloader extends AsyncTask&lt;Void, Void, Bitmap&gt;{
	private ImageView imageView;
	private String fileName;</p>

<pre><code>public AsyncImageDownloader(ImageView imageView, String fileName){
	this.imageView = imageView;
	this.fileName = fileName;
}

@Override
protected void onPreExecute() {
	super.onPreExecute();
	imageView.setImageResource(R.drawable.placeholder);
}

@Override
protected Bitmap doInBackground(Void... arg0) {
	String url = Utils.getRealUrlOfPicture(fileName);
	HttpResponse response = new HttpRetriever().requestGet(url, null);
	Log.i(TAG, "url: " + url);
	Log.i(TAG, "respone: " + response);
	InputStream in = null;
	try {
		if(response != null &amp;&amp; response.getEntity() != null)
			in = response.getEntity().getContent();
	} catch (IllegalStateException e) {
		e.printStackTrace();
		return null;
	} catch (IOException e) {
		e.printStackTrace();
		return null;
	}
	
	//TODO to be optimized: adjust the size of bitmap
	return BitmapFactory.decodeStream(in);
}

@Override
protected void onPostExecute(Bitmap result) {
	super.onPostExecute(result);
	if(result != null &amp;&amp; imageView != null)
		imageView.setImageBitmap(result);
	
	//TODO cache the bitmap both in sdcard &amp; memory
	memoryCache.put(fileName, result);// key is a unique token, value is the bitmap
	
	fileCache.put(fileName, result);
} } ```
</code></pre>

<p>可以看到这个类的构造函数需要两个参数，分别是文件名和对应要显示的<code>ImageView</code>，那么在任务开始的时候，可以为该<code>ImageView</code>设置未下载状态的图片，然后下载完成后更新UI。</p>

<blockquote>
  <p>注：需要提醒的是，这里的唯一key值，我使用的是文件名，因为我接收到的文件名是唯一的。猿媛们也可以根据自己的需求，设计自己的唯一key值算法。</p>
</blockquote>

<p>接下来，我们需要读用<code>key</code>值索引相应的<code>Bitmap</code>：</p>

<p>```java
public Bitmap getBitmap(String key){
	Bitmap bitmap = null;
	//1. search memory
	bitmap = memoryCache.get(key);</p>

<pre><code>//2. search sdcard
if(bitmap == null){
	File file = fileCache.getFile(key);
	if(file != null)
		bitmap = BitmapHelper.decodeFile(file, null);
}

return bitmap; } ``` 到这里，一个简单的缓存框架就搭建成功了。它简洁有效，但是非常单薄，似乎不够强大，需要你们根据自己的需求进行修改。另外它本来的目的就是用于演示，理解这个以后，我们再来看``Google``的``BitmapFun``。
</code></pre>

<p>不过，我将它应用在一个小项目中，性能还不错。对于小项目的需求，应该是够的。</p>

<p>最后，附上使用方法，以及整个类的代码。</p>

<h2 id="section">使用</h2>

<p><code>java
AsyncImageLoader imageLoader = AsyncImageLoader.getInstance(this);、
imageLoader.displayBitmap(imageView, fileName);
</code></p>

<h2 id="asyncimageloader">AsyncImageLoader</h2>

<p>```java
public class AsyncImageLoader {</p>

<pre><code>private static final String TAG = "AsyncImageLoader";

//caches
private MemoryCache memoryCache;
private FileCache fileCache;
//Asynchronous task
private static AsyncImageLoader imageLoader;

class AsyncImageDownloader extends AsyncTask&lt;Void, Void, Bitmap&gt;{
	private ImageView imageView;
	private String fileName;
	
	public AsyncImageDownloader(ImageView imageView, String fileName){
		this.imageView = imageView;
		this.fileName = fileName;
	}
	
	@Override
	protected void onPreExecute() {
		super.onPreExecute();
		imageView.setImageResource(R.drawable.placeholder);
	}
	
	@Override
	protected Bitmap doInBackground(Void... arg0) {
		String url = Utils.getRealUrlOfPicture(fileName);
		HttpResponse response = new HttpRetriever().requestGet(url, null);
		Log.i(TAG, "url: " + url);
		Log.i(TAG, "respone: " + response);
		InputStream in = null;
		try {
			if(response != null &amp;&amp; response.getEntity() != null)
				in = response.getEntity().getContent();
		} catch (IllegalStateException e) {
			e.printStackTrace();
			return null;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
		
		//TODO to be optimized: adjust the size of bitmap
		return BitmapFactory.decodeStream(in);
	}
	
	@Override
	protected void onPostExecute(Bitmap result) {
		super.onPostExecute(result);
		if(result != null &amp;&amp; imageView != null)
			imageView.setImageBitmap(result);
		
		//TODO cache the bitmap both in sdcard &amp; memory
		memoryCache.put(fileName, result);// key is a unique token, value is the bitmap
		
		fileCache.put(fileName, result);
	}
}

private AsyncImageLoader(Context context){
	this.memoryCache 		= 	new MemoryCache();
	this.fileCache			= 	new FileCache(context);
}

public static AsyncImageLoader getInstance(Context context){
	if(imageLoader == null)
		imageLoader = new AsyncImageLoader(context);
	
	return imageLoader;
}

public void displayBitmap(ImageView imageView, String fileName){
	//no pic for this item
	if(fileName == null || "".equals(fileName))
		return;
	
	Bitmap bitmap = getBitmap(fileName);
	//search in cache, if there is no such bitmap, launch downloads
	if(bitmap != null){
		imageView.setImageBitmap(bitmap);
	}
	else{
		Log.w(TAG, "Can't find the file you required.");
		new AsyncImageDownloader(imageView, fileName).execute();
	}
}

public Bitmap getBitmap(String key){
	Bitmap bitmap = null;
	//1. search memory
	bitmap = memoryCache.get(key);
	
	//2. search sdcard
	if(bitmap == null){
		File file = fileCache.getFile(key);
		if(file != null)
			bitmap = BitmapHelper.decodeFile(file, null);
	}
	
	return bitmap;
}

public void clearCache(){
	if(memoryCache != null)
		memoryCache.clear();
	if(fileCache != null)
		fileCache.clear();
} } ```
</code></pre>

<h2 id="section-1">源码</h2>

<p>附上源码，不过服务器的源码暂时还没有放出来，先看看客户端的吧。</p>

<p><a href="https://github.com/ryanhoo/SoftRead">https://github.com/ryanhoo/SoftRead</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（二）Memory Cache & File Cache]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/05/build-android-cache-module-2/"/>
    <updated>2014-06-05T23:34:36+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/05/build-android-cache-module-2</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#memory-cache">Memory Cache</a></li>
  <li><a href="#file-cache">File Cache</a></li>
</ul>

<p>上一篇博客我们讲到普通应用缓存Bitmap的实现分析，根据 MVC 的实现原理，我将这个简单的缓存实现单独写成一个模块，这样可以方便以后的使用，对于任意的需求，都属于一个可插拔式的功能。</p>

<p>之前提到，这个缓存模块主要有两个子部件：</p>

<h2 id="memory-cache">Memory Cache</h2>

<p>内存缓存的存取速度非常惊人，远远快于文件读取，如果没有内存限制，当然首选这种方式。遗憾的是我们有着<strong>16M</strong>的限制（当然大多数设备限制要高于 Android 官方说的这个数字），这也正是大 Bitmap容易引起 OOM 的原因。Memory Cache 将使用 <code>WeakHashMap</code> 作为缓存的中枢，当程序内存告急时，它会主动清理部分弱引用（因此，当引用指向为 null ，我们必须转向硬盘缓存读取数据，如果硬盘也没有，那还是重新下载吧）。</p>

<p>能力越大，责任越大？人家只是跑得快了点儿，总得让人家休息，我们一定不希望让内存成为第一位跑完马拉松的 Pheidippides ，一次以后就挂了吧？作为精打细算的猿媛，我们只能将有限的内存分配给 Memory Cache ，将更繁重的任务托付给任劳任怨的 SDCard 。</p>

<h2 id="file-cache">File Cache</h2>

<p>硬盘读取速度当然不如内存，但是为了珍惜宝贵的流量，不让你的用户在月底没有流量时嚎叫着要删掉你开发的“流量杀手”，最好是避免重复下载。在第一次下载以后，将数据保存在本地即可。</p>

<p>文件读写的技术并不是很新颖的技术，Java Core 那点儿就够你用了。不过要记得我们可是将Bitmap写入文件啊，怎么写入呢？不用着急，Android 的 Bitmap 本身就具备将数据写入 OutputStream 的能力。我将这些额外的方法写在一个帮助类中：BitmapHelper</p>

<p><code>java
public static boolean saveBitmap(File file, Bitmap bitmap){
	if(file == null || bitmap == null)
		return false;
	try {
		BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));
		return bitmap.compress(CompressFormat.JPEG, 100, out);
	} catch (FileNotFoundException e) {
		e.printStackTrace();
		return false;
	}
}
</code></p>

<p>最后附上Memory Cache和File Cache的具体代码，非常简单。</p>

<p>```java
public class MemoryCache {
	private static final String TAG = “MemoryCache”;</p>

<pre><code>//WeakReference Map: key=string, value=Bitmap
private WeakHashMap&lt;String, Bitmap&gt; cache = new WeakHashMap&lt;String, Bitmap&gt;();

/**
 * Search the memory cache by a unique key. 
 * @param key Should be unique. 
 * @return The Bitmap object in memory cache corresponding to specific key.
 * */
public Bitmap get(String key){
    if(key != null)
    	return cache.get(key);
    return null;
}

/**
 * Put a bitmap into cache with a unique key.
 * @param key Should be unique.
 * @param value A bitmap.
 * */
public void put(String key, Bitmap value){
	if(key != null &amp;&amp; !"".equals(key) &amp;&amp; value != null){
		cache.put(key, value);
		//Log.i(TAG, "cache bitmap: " + key);
		Log.d(TAG, "size of memory cache: " + cache.size());
	}
}

/**
 * clear the memory cache.
 * */
public void clear() {
    cache.clear();
} } ```
</code></pre>

<p>```java
public class FileCache {</p>

<pre><code>private static final String TAG = "MemoryCache";

private File cacheDir;	//the directory to save images

/**
 * Constructor
 * @param context The context related to this cache.
 * */
public FileCache(Context context) {
	// Find the directory to save cached images
	if (android.os.Environment.getExternalStorageState()
			.equals(android.os.Environment.MEDIA_MOUNTED))
		cacheDir = new File(
				android.os.Environment.getExternalStorageDirectory(),
				Config.CACHE_DIR);
	else
		cacheDir = context.getCacheDir();
	if (!cacheDir.exists())
		cacheDir.mkdirs();
	
	Log.d(TAG, "cache dir: " + cacheDir.getAbsolutePath());
}

/**
 * Search the specific image file with a unique key.
 * @param key Should be unique.
 * @return Returns the image file corresponding to the key.
 * */
public File getFile(String key) {
	File f = new File(cacheDir, key);
	if (f.exists()){
		Log.i(TAG, "the file you wanted exists " + f.getAbsolutePath());
		return f;
	}else{
		Log.w(TAG, "the file you wanted does not exists: " + f.getAbsolutePath());
	}

	return null;
}

/**
 * Put a bitmap into cache with a unique key.
 * @param key Should be unique.
 * @param value A bitmap.
 * */
public void put(String key, Bitmap value){
	File f = new File(cacheDir, key);
	if(!f.exists())
		try {
			f.createNewFile();
		} catch (IOException e) {
			e.printStackTrace();
		}
	//Use the util's function to save the bitmap.
	if(BitmapHelper.saveBitmap(f, value))
		Log.d(TAG, "Save file to sdcard successfully!");
	else
		Log.w(TAG, "Save file to sdcard failed!");
	
}

/**
 * Clear the cache directory on sdcard.
 * */
public void clear() {
	File[] files = cacheDir.listFiles();
	for (File f : files)
		f.delete();
} } ```
</code></pre>

<p>没什么难的地方，直接贴代码。下一篇博客我将讲解如何使用异步任务下载数据，以及使用Controller操作Model，控制View的显示。 </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【构建Android缓存模块】（一）吐槽与原理分析]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/04/build-android-cache-module-1/"/>
    <updated>2014-06-04T22:32:52+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/04/build-android-cache-module-1</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">摘要</a></li>
  <li><a href="#section-1">前言</a></li>
  <li><a href="#section-2">自力更生，构建自己的缓存模块</a></li>
  <li><a href="#oom">如何解决OOM</a></li>
  <li><a href="#section-3">佛说引用，既非引用，是名引用。</a></li>
  <li><a href="#section-4">原理示意图</a></li>
  <li><a href="#section-5">参考资料</a></li>
</ul>

<h2 id="section">摘要</h2>

<p>在我翻译的 <a href="http://my.oschina.net/ryanhoo/blog?catalog=260281">Google 官方系列教程</a>中，Bitmap 系列由浅入深地介绍了如何正确的解码 Bitmap ，异步线程操作以及使用 Fragments 重用等技术，并且在最后给出了非常强大的独家秘笈：<code>BitmapFun</code> ，让猿媛们得以一窥究竟 Google 的攻城师们是如何高屋建瓴地秒杀 <strong>OOM</strong> 的。</p>

<h2 id="section-1">前言</h2>

<p>在下载到 <a href="http://vdisk.weibo.com/s/hNgFB">BitmapFun.rar</a> 这个神圣的压缩包以后，我是双手颤抖，似乎是打开上古秘藏一般，心情激动导致久久不能自已。我还记得那天上海下着小雨，我当时霍然起身，伫立在 23 楼的窗台，仰着头向江水对岸的东方明珠望去，似乎这样我郁积已久的眼泪就不能掉下来。说到这里，Ryan 又暗自抹了一把眼泪。短暂地忘记了过去的黑暗时光，那一个漫长的被 <strong>OOM</strong> 的淫威所折磨的盛夏。。。</p>

<p>最后在 Boss诧异的目光中，我回到办公桌，按捺着内心汹涌的情绪波动，然后小心翼翼的打开 BitmapFun.rar 。当那些在洪荒时代就活跃在Android平台的大师们书写的篇章呈现在我眼前时，我的表情与阿宝从师父手里得到 <strong>Dragon Scroll</strong> 时一般，永久的定格在了极度天真的期待与眼角一抽一抽的状态。</p>

<p>那些泛黄的代码在我看去，通篇只有一句话：<code>老子看不懂！</code></p>

<h2 id="section-2">自力更生，构建自己的缓存模块</h2>

<p>Google 的这个 demo 堪称详尽，考虑极其周详，自然是极好的。但是当原理被层层的“特殊情况”包装起来，原本简单的例子变得异常复杂，几个类之间的关系错综复杂，堪比吸血鬼日记几个帅哥美女之间的关系。要理解清楚每一句代码的含义，你一定要有理解 Matt 那人老珠黄的老娘和他和失落的好朋友 Taylor 搞在一起的觉悟。</p>

<p>好了，吐槽一下就收，千万不要怀疑 Google ，人家已经仁至义尽了。 BitmapFun 中在下载后将 Bitmap 缓存起来，缓存做了两份：<code>LruCache</code> 和 <code>DiskLruCache</code> ，分别是内存缓存和硬盘缓存。此外两个至关重要的类是：</p>

<p>```java
BitmapWorkerTask(ImageView imageView)</p>

<p>AsyncDrawable extends BitmapDrawable
    AsyncDrawable(Resources res, Bitmap bitmap,BitmapWorkerTask bitmapWorkerTask)  <br />
```</p>

<p><code>BitmapWorkerTask</code> 持有一个 <code>WeakReference&lt;ImageView&gt; imageViewReference</code> ，弱引用 <code>ImageView</code> ，用作异步处理加载图片的任务。
<code>AsyncDrawable</code> 巧妙的引用持有弱引用 <code>WeakReference&lt;BitmapWorkerTask&gt; bitmapWorkerTaskReference</code> ，是 <code>BitmapDrawable</code> 的子类，这样就可以 <code>setImageBitmap(AsyncDrawable)</code>。</p>

<p>关系：<code>AsyncDrawable</code> 中弱引用 <code>BitmapWorkerTask</code> 。其实是图片引用 <code>ImageView</code> 的关系，而<code>ImageView.getDrawable</code> 又可以获得图片。这种高妙的思想不是正值得我们学习么？   </p>

<p>当然，这节课并不是讲解官方Demo的，在讲解它之前，我们先来学习一个更加简单的缓存实现方案，使用最简单的方式快速构建自己应用的缓存模块，有效避免 OOM 异常。它的难度非常小也很方便理解，可以在这个缓存实现的基础上，我们再去理解更加高妙的 BitmapFun 的缓存实现方案。</p>

<h2 id="oom">如何解决OOM</h2>

<p>Bitmap 之所以容易引起OOM异常，原因已经在 Bitmap 系列教程中说的明明白白。但是我们至少清楚一点：一个手机屏幕再大，合理尺寸的 Bitmap 也不至于耗空所有内存，那要怎么做才能避免 OOM 呢？</p>

<ul>
  <li>加载合理尺寸的 Bitmap </li>
  <li>避免反复解码、重复加载 Bitmap</li>
  <li>控制 Bitmap 的生命周期，合理回收</li>
</ul>

<p>此外网上也有不少歪门邪道，我个人认为是不可取的，使用这些简单粗暴的方法，后期会为你带来更大的麻烦：</p>

<ul>
  <li>减损图片质量（使用过高的 inSampleSize 值）</li>
  <li>使用 decodeStream （绕过 Java 层，直接调用 JNI ）</li>
  <li>强制增加heap size</li>
  <li>其他</li>
</ul>

<p>控制Bitmap的生命周期才是正解， BitmapFun 使用的 LruCache 是将它将最近被引用到的对象存储在一个强引用的 LinkedHashMap 中，并且在缓存超过了指定大小之后将最近不常使用的对象释放掉。</p>

<p>Memory Cache 的 Size 是受限的，因此加入 DiskLruCache ，虽然在访问速度上逊于 Memory Cache ，但是速度也是相当可观的。</p>

<p>借鉴 Google 的做法，我也将缓存做了两份，一份是 Memory Cache ，使用弱引用的 WeakHashMap 来控制 Bitmap 的生命周期，后面会有详细解释。另一份严格来说不能算是缓存，直接将文件存储在 SDCard 上，避免重复下载。</p>

<h2 id="section-3">佛说引用，既非引用，是名引用。</h2>

<p>关于引用，或许对于小菜鸟们不是很好理解（我碰到过太多 Java 都没学好来做 Android 的，基础很重要！）。我使用金刚经的著名三段论来解释它：<code>佛说XX，既非XX，是名XX。</code></p>

<p>这句话什么意思呢？比如佛说大米，既可以说它不是大米，只是名字叫做大米罢了。不会因为你为它改名叫做大麦而改变它的本质，你叫它做水，吃到嘴里的还是原来的味道。</p>

<p>关于引用，跟这个有着非常相似的共性。引用就相当于实际对象的名字，比如下面的例子：</p>

<p><code>java
Person p1 = new Person();
Person p2 = null;
p2 = p1;
p1 = null;
</code>
<code>new Person()</code>这个对象的名是 p1 ，而后你将名字改成了 p2 ，对象还是那个对象，不会因为你将 p1 的大名盖在 null 的头上而改变它的本质。以上的 p1 和 p2 都是引用，它们都不过是名。</p>

<blockquote>
  <p>在了解到引用的含义后，虚拟机会告诉你，被引用的对象处于可获得( reachable )状态，它是你的好管家，既然你要用它，它就不会回收它。（你想想如果你正在吃一只烤鸭，人家突然一把抢了过去扔垃圾桶了你什么感觉。）</p>
</blockquote>

<blockquote>
  <p>如果在上面的那段程序后面加上 <code>p2 = null</code>，Person 这个对象就没有任何引用指向它了，垃圾回收器会在不确定的时间进行回收。（你都把东西扔了，总不能不让人家收破烂吧？）</p>
</blockquote>

<blockquote>
  <p>如果你想继续持有这个对象的引用，希望可以继续访问，但是也允许垃圾回收器进行回收，该怎么办呢？（你想减肥，告诉你的好朋友说，如果察觉到你太胖了，就将你嘴里的烤鸭抢去扔了。如果你很饿，身材也不错，你要继续吃。）</p>
</blockquote>

<p>这个时候，我们需要借助 Java 提供的软/弱/虚引用。我们平时使用的如 p1 和 p2 这样的叫做强引用(Strong Reference)。要使垃圾回收器能在内存不够的时候，主动抢下你嘴里的烤鸭，进行回收，需要使用这些：</p>

<ul>
  <li>软引用：SoftReference</li>
  <li>弱引用：WeakReference</li>
  <li>虚引用：PhantomReference</li>
</ul>

<p>它们按照由强到弱的引用关系排列，虚引用相当于几乎没有引用。文艺青年常说的若即若离用来形容它再恰当不过了。</p>

<p>关于这三个引用的具体学习，详见我提供的参考资料。这里只是向你解释为什么使用弱引用可以起到防止 Bitmap 过多而导致内存紧张的作用。</p>

<p>在这里，由于我需要使用 Bitmap 和名字的 key-value 对应关系，我使用 Java 提供的 <code>WeakHashMap(String key, Bitmap value)</code> ，顾名思义，它用来保存 WeakReference ，并且确保每个 key 只对应一个值，在内存不够的时候，垃圾回收器会进行回收。当 key 值索引不到 Bitmap ，再进行其他的操作。</p>

<h2 id="section-4">原理示意图</h2>

<p>我将原理画成图，以便大家的理解。主体有三个，分别是 UI ，缓存模块和数据源。它们之间的关系如下：</p>

<p><img src="images/blog/android/130726_4p9B_245415.png" alt="原理示意图" /></p>

<p>① UI：请求数据，使用唯一的 Key 值索引 Memory Cache 中的 Bitmap 。</p>

<p>② 内存缓存：缓存搜索，如果能找到 Key 值对应的 Bitmap ，则返回数据。否则执行第三步。</p>

<p>③ 硬盘存储：使用唯一 Key 值对应的文件名，检索 SDCard 上的文件。</p>

<p>④ 如果有对应文件，使用 BitmapFactory.decode* 方法，解码 Bitmap 并返回数据，同时将数据写入缓存。如果没有对应文件，执行第五步。</p>

<p>⑤ 下载图片：启动异步线程，从数据源下载数据(Web)。</p>

<p>⑥ 若下载成功，将数据同时写入硬盘和缓存，并将 Bitmap 显示在 UI 中。</p>

<p>总结：这节课除了吐槽，主要的还是原理分析。如果你有更好的缓存方案，欢迎提出。下节课将讲解具体的 Memory Cache 和 FileCache 如何实现。</p>

<h2 id="section-5">参考资料</h2>

<p>【1】<a href="http://vdisk.weibo.com/s/jtqjr">Thinking In Java 4th Chapter 17.12 Hoding References.pdf</a></p>

<p>【2】<a href="http://vdisk.weibo.com/s/jtqjr">李刚：突破程序员基本功的16课之Java的内存回收.pdf</a>  </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android大图片裁剪终极解决方案（下：拍照截图）]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-3/"/>
    <updated>2014-06-03T22:34:51+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-3</id>
    <content type="html"><![CDATA[<p>上一篇博客中，我们学习到了如何使用Android相册截图。在这篇博客中，我将向大家展示如何拍照截图。</p>

<p>拍照截图有点儿特殊，要知道，现在的Android智能手机的摄像头都是几百万的像素，拍出来的图片都是非常大的。因此，我们不能像对待相册截图一样使用Bitmap小图，无论大图小图都统一使用Uri进行操作。</p>

<h4 id="uri">一、首先准备好需要使用到的Uri：</h4>

<p><code>java
private static final String IMAGE_FILE_LOCATION = "file:///sdcard/temp.jpg";//temp file
Uri imageUri = Uri.parse(IMAGE_FILE_LOCATION);//The Uri to store the big bitmap
</code></p>

<h4 id="mediastoreactionimagecapturecamera">二、使用MediaStore.ACTION_IMAGE_CAPTURE可以轻松调用Camera程序进行拍照：</h4>

<p><code>java
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//action is capture
intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
startActivityForResult(intent, TAKE_BIG_PICTURE);//or TAKE_SMALL_PICTURE
</code></p>

<h4 id="onactivityresulturiuri">三、接下来就可以在 onActivityResult中拿到返回的数据（Uri），并将Uri传递给截图的程序。</h4>

<p>```java
switch (requestCode) {
case TAKE_BIG_PICTURE:
	Log.d(TAG, “TAKE_BIG_PICTURE: data = “ + data);//it seems to be null
	//TODO sent to crop
	cropImageUri(imageUri, 800, 400, CROP_BIG_PICTURE);</p>

<pre><code>break; case TAKE_SMALL_PICTURE:
Log.i(TAG, "TAKE_SMALL_PICTURE: data = " + data);
//TODO sent to crop 
cropImageUri(imageUri, 300, 150, CROP_SMALL_PICTURE);

break; } ```
</code></pre>

<p>可以看到，无论是拍大图片还是小图片，都是使用的Uri，只是尺寸不同而已。我们将这个操作封装在一个方法里面。</p>

<p><code>java
private void cropImageUri(Uri uri, int outputX, int outputY, int requestCode){
	Intent intent = new Intent("com.android.camera.action.CROP");
	intent.setDataAndType(uri, "image/*");
	intent.putExtra("crop", "true");
	intent.putExtra("aspectX", 2);
	intent.putExtra("aspectY", 1);
	intent.putExtra("outputX", outputX);
	intent.putExtra("outputY", outputY);
	intent.putExtra("scale", true);
	intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
	intent.putExtra("return-data", false);
	intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
	intent.putExtra("noFaceDetection", true); // no face detection
	startActivityForResult(intent, requestCode);
}
</code></p>

<h4 id="section">四、最后一步，我们已经将数据传入裁剪图片程序，接下来要做的就是处理返回的数据了：</h4>

<p><code>java
switch (requestCode) {
case CROP_BIG_PICTURE://from crop_big_picture
	Log.d(TAG, "CROP_BIG_PICTURE: data = " + data);//it seems to be null
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);
		imageView.setImageBitmap(bitmap);
	}
	break;
case CROP_SMALL_PICTURE:
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);
		imageView.setImageBitmap(bitmap);
	}else{
		Log.e(TAG, "CROP_SMALL_PICTURE: data = " + data);
	}
	break;
default:
	break;
}
</code></p>

<h4 id="section-1">效果图：</h4>

<p><img src="images/blog/android/184229_tlMc_245415.gif" alt="截图演示" /></p>

<blockquote>
  <p>代码托管于GitHub，会不定期更新：<a href="https://github.com/ryanhoo/PhotoCropper">https://github.com/ryanhoo/PhotoCropper</a></p>
</blockquote>

]]></content>
  </entry>
  
</feed>
