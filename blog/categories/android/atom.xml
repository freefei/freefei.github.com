<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Ryan Hoo]]></title>
  <link href="http://ryanhoo.github.io/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://ryanhoo.github.io/"/>
  <updated>2014-06-03T22:47:12+08:00</updated>
  <id>http://ryanhoo.github.io/</id>
  <author>
    <name><![CDATA[Ryan Hoo]]></name>
    <email><![CDATA[ryan.hoo.j@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android大图片裁剪终极解决方案（下：拍照截图）]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-3/"/>
    <updated>2014-06-03T22:34:51+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-3</id>
    <content type="html"><![CDATA[<p>上一篇博客中，我们学习到了如何使用Android相册截图。在这篇博客中，我将向大家展示如何拍照截图。</p>

<p>拍照截图有点儿特殊，要知道，现在的Android智能手机的摄像头都是几百万的像素，拍出来的图片都是非常大的。因此，我们不能像对待相册截图一样使用Bitmap小图，无论大图小图都统一使用Uri进行操作。</p>

<h4 id="uri">一、首先准备好需要使用到的Uri：</h4>

<p><code>java
private static final String IMAGE_FILE_LOCATION = "file:///sdcard/temp.jpg";//temp file
Uri imageUri = Uri.parse(IMAGE_FILE_LOCATION);//The Uri to store the big bitmap
</code></p>

<h4 id="mediastoreactionimagecapturecamera">二、使用MediaStore.ACTION_IMAGE_CAPTURE可以轻松调用Camera程序进行拍照：</h4>

<p><code>java
Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//action is capture
intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
startActivityForResult(intent, TAKE_BIG_PICTURE);//or TAKE_SMALL_PICTURE
</code></p>

<h4 id="onactivityresulturiuri">三、接下来就可以在 onActivityResult中拿到返回的数据（Uri），并将Uri传递给截图的程序。</h4>

<p>```java
switch (requestCode) {
case TAKE_BIG_PICTURE:
	Log.d(TAG, “TAKE_BIG_PICTURE: data = “ + data);//it seems to be null
	//TODO sent to crop
	cropImageUri(imageUri, 800, 400, CROP_BIG_PICTURE);</p>

<pre><code>break; case TAKE_SMALL_PICTURE:
Log.i(TAG, "TAKE_SMALL_PICTURE: data = " + data);
//TODO sent to crop 
cropImageUri(imageUri, 300, 150, CROP_SMALL_PICTURE);

break; } ```
</code></pre>

<p>可以看到，无论是拍大图片还是小图片，都是使用的Uri，只是尺寸不同而已。我们将这个操作封装在一个方法里面。</p>

<p><code>java
private void cropImageUri(Uri uri, int outputX, int outputY, int requestCode){
	Intent intent = new Intent("com.android.camera.action.CROP");
	intent.setDataAndType(uri, "image/*");
	intent.putExtra("crop", "true");
	intent.putExtra("aspectX", 2);
	intent.putExtra("aspectY", 1);
	intent.putExtra("outputX", outputX);
	intent.putExtra("outputY", outputY);
	intent.putExtra("scale", true);
	intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);
	intent.putExtra("return-data", false);
	intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
	intent.putExtra("noFaceDetection", true); // no face detection
	startActivityForResult(intent, requestCode);
}
</code></p>

<h4 id="section">四、最后一步，我们已经将数据传入裁剪图片程序，接下来要做的就是处理返回的数据了：</h4>

<p><code>java
switch (requestCode) {
case CROP_BIG_PICTURE://from crop_big_picture
	Log.d(TAG, "CROP_BIG_PICTURE: data = " + data);//it seems to be null
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);
		imageView.setImageBitmap(bitmap);
	}
	break;
case CROP_SMALL_PICTURE:
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);
		imageView.setImageBitmap(bitmap);
	}else{
		Log.e(TAG, "CROP_SMALL_PICTURE: data = " + data);
	}
	break;
default:
	break;
}
</code></p>

<h4 id="section-1">效果图：</h4>

<p><img src="images/blog/android/184229_tlMc_245415.gif" alt="截图演示" /></p>

<blockquote>
  <p>代码托管于GitHub，会不定期更新：<a href="https://github.com/ryanhoo/PhotoCropper">https://github.com/ryanhoo/PhotoCropper</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android大图片裁剪终极解决方案（中：从相册截图）]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-2/"/>
    <updated>2014-06-03T22:21:35+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/06/03/the-ultimate-approach-to-crop-photos-on-android-2</id>
    <content type="html"><![CDATA[<p>在这篇博客中，我将向大家展示如何从相册截图。</p>

<p>上一篇博客中，我就拍照截图这一需求进行了详细的分析，试图让大家了解Android本身的限制，以及我们应当采取的实现方案。</p>

<p>根据我们的分析与总结，图片的来源有拍照和相册，而可采取的操作有</p>

<ul>
  <li>使用Bitmap并返回数据</li>
  <li>使用Uri不返回数据</li>
</ul>

<p>前面我们了解到，使用Bitmap有可能会导致图片过大，而不能返回实际大小的图片，我将采用大图Uri，小图Bitmap的数据存储方式。</p>

<p>我们将要使用到URI来保存拍照后的图片：</p>

<p><code>java
static final String IMAGE_FILE_LOCATION = "file:///sdcard/temp.jpg";//temp file
Uri imageUri = Uri.parse(IMAGE_FILE_LOCATION);//The Uri to store the big bitmap
</code></p>

<p>不难知道，我们从相册选取图片的<strong>Action</strong>为<code>Intent.ACTION_GET_CONTENT</code>。</p>

<p>根据我们上一篇博客的分析，我准备好了两个实例的Intent。</p>

<h4 id="section">一、从相册截大图：</h4>

<p><code>java
Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
intent.setType("image/*");
intent.putExtra("crop", "true");
intent.putExtra("aspectX", 2);
intent.putExtra("aspectY", 1);
intent.putExtra("outputX", 600);
intent.putExtra("outputY", 300);
intent.putExtra("scale", true);
intent.putExtra("return-data", false);
intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri);
intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
intent.putExtra("noFaceDetection", true); // no face detection
startActivityForResult(intent, CHOOSE_BIG_PICTURE);
</code></p>

<h4 id="section-1">二、从相册截小图</h4>

<p><code>java
Intent intent = new Intent(Intent.ACTION_GET_CONTENT, null);
intent.setType("image/*");
intent.putExtra("crop", "true");
intent.putExtra("aspectX", 2);
intent.putExtra("aspectY", 1);
intent.putExtra("outputX", 200);
intent.putExtra("outputY", 100);
intent.putExtra("scale", true);
intent.putExtra("return-data", true);
intent.putExtra("outputFormat", Bitmap.CompressFormat.JPEG.toString());
intent.putExtra("noFaceDetection", true); // no face detection
startActivityForResult(intent, CHOOSE_SMALL_PICTURE);
</code></p>

<h4 id="onactivityresult">三、对应的onActivityResult可以这样处理返回的数据</h4>

<p><code>java
switch (requestCode) {
case CHOOSE_BIG_PICTURE:
	Log.d(TAG, "CHOOSE_BIG_PICTURE: data = " + data);//it seems to be null
	if(imageUri != null){
		Bitmap bitmap = decodeUriAsBitmap(imageUri);//decode bitmap
		imageView.setImageBitmap(bitmap);
	}
break;
case CHOOSE_SMALL_PICTURE:
	if(data != null){
		Bitmap bitmap = data.getParcelableExtra("data");
		imageView.setImageBitmap(bitmap);
	}else{
		Log.e(TAG, "CHOOSE_SMALL_PICTURE: data = " + data);
	}
break;
}
</code></p>

<h4 id="section-2">效果图</h4>

<p><img src="/images/blog/android/183645_yuLJ_245415.gif" alt="大图" /></p>

<p><img src="/images/blog/android/183707_DnNy_245415.gif" alt="小图" /></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android大图片裁剪终极解决方案（上：原理分析）]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/05/26/the-ultimate-approach-to-crop-photos-on-android-1/"/>
    <updated>2014-05-26T17:37:42+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/05/26/the-ultimate-approach-to-crop-photos-on-android-1</id>
    <content type="html"><![CDATA[
<p>约几个月前，我正为公司的APP在Android手机上实现拍照截图而烦恼不已。</p>

<p>上网搜索，确实有不少的例子，大多都是抄来抄去，而且水平多半处于demo的样子，可以用来讲解知识点，但是一碰到实际项目，就漏洞百出。</p>

<p>当时我用大众化的解决方案，暂时性的做了一个拍照截图的功能，似乎看起来很不错。可是问题随之而来，我用的是小米手机，在别的手机上都运行正常，在小米这里却总是碰钉子。虽然我是个理性的米粉，但是也暗地里把小米的工程师问候了个遍。真是惭愧！</p>

<p>翻文档也找不出个答案来，我一直对<strong>com.android.camera.action.CROP</strong>持有大大的疑问，它是从哪里来，它能干什么，它接收处理什么类型的数据？Google对此却讳莫如深，在官方文档中只有Intent中有只言片语言及，却不甚详尽。</p>

<p>随着项目的驱动，我不能抱着不了解原理就不往前走的心态，唯一要做的，是解决问题。最后在德问上找到一条解决方案，说是哪怕是大米也没问题。当时乐呵呵将代码改了改，确实在所有的手机上跑起来了，一时如释重负，对这个的疑问也抛诸脑后了。</p>

<p>直到月前，BOSS要求将拍照上传到服务器的图片分辨率加倍。OK，加倍简单，增加<code>outputX</code>以及<code>outputY</code>不就得了？</p>

<p><code>java
intent.putExtra("outputX", outputX);
intent.putExtra("outputY", outputY);
</code></p>

<p>这一增加，吓了我一跳。BOSS的手机拍到的照片几乎就是个缩略图，但是被我问候了全体工程师的小米在这个时候就体现出国产神机的范儿了，小米上的尺寸一切正常。这个为什么呢？我大致了解原因，却不知道如何解决。</p>

<p>在Android中，Intent触发Camera程序，拍好照片后，将会返回数据，但是考虑到内存问题，Camera不会将全尺寸的图像返回给调用的Activity，一般情况下，有可能返回的是缩略图，比如<strong>120*160px</strong>。</p>

<p>这是为什么呢？这不是一个Bug，而是经过精心设计的，却对开发者不透明。</p>

<p>以我的小米手机为例，摄像头800W像素，根据我目前设置拍出来的图片尺寸为<strong>3200*2400px</strong>。有人说，那就返回呗，大不了耗1-2M的内存，不错，这个尺寸的图片确实只有1.8M左右的大小。但是你想不到的是，这个尺寸对应的Bitmap会耗光你应用程序的所有内存。Android出于安全性考虑，只会给你一个寒碜的缩略图。</p>

<p>在Android2.3中，默认的Bitmap为32位，类型是<code>ARGB_8888</code>，也就意味着一个像素点占用4个字节的内存。我们来做一个简单的计算题：</p>

<p><code>3200*2400*4 bytes =   30M</code></p>

<p>如此惊人的数字！哪怕你愿意为一张生命周期超不过10s的位图愿意耗费这么巨大的内存，Android也不会答应的。</p>

<blockquote>
  <p>Mobile devices typically have constrained system resources. 
Android devices can have as little as 16MB of memory available to a single application.</p>
</blockquote>

<p>这是Android Doc的原文，虽然不同手机系统的厂商可能围绕16M这个数字有微微的上调，但是这30M，一般的手机还真挥霍不起。也只有小米这种牛机，内存堪比个人PC，本着土财主般挥金如土的霸气才能做到。</p>

<p>OK，说了这么多，无非是吐吐苦水，爆爆个人经历而已，实际的解决方案在哪里呢？</p>

<p>我也是Google到的，话说一般百度不了的问题，那就<code>Google</code>或者直接<code>StackOverFlow</code>，只不过得看英文罢了。</p>

<p>最后翻来覆去，我在国外的一个Android团队的博客中找到了相应的方案，印证了我的猜想同时也给出了实际的代码。</p>

<p>我将这篇文章翻译成了中文，作为本博客的基础，建议详细看看。</p>

<p><a href="http://my.oschina.net/ryanhoo/blog/86843">【译】如何使用Android MediaStore裁剪大图片</a></p>

<p>这篇博客了不起的地方在于解决了Android对返回图片的大小限制，并且详细解释了裁剪图片的<code>Intent</code>附加数据的具体含义。我只是站在巨人的肩膀上，改善方案，适应更广泛需求而已。</p>

<p>拿图说事儿：</p>

<p><img src="/images/blog/android/144805_wCcI_245415.png" alt="Intent Options" /></p>

<p><code>Intent("com.android.camera.action.CROP")</code>对应的所有可选数据都一目了然。在了解上面个个选项的含义之后，我们将目光着眼于三个极为重要的选项：</p>

<ul>
  <li>data</li>
  <li>MediaStore.EXTRA_OUTPUT</li>
  <li>return-data</li>
</ul>

<p><code>data和MediaStore.EXTRA_OUTPUT</code>都是可选的传入数据选项，你可以选择设置data为Bitmap，或者将相应的数据与URI关联起来，你也可以选择是否返回数据（return-data: true）。</p>

<p>为什么还有不用返回数据的选项？如果对URI足够了解的话，应该知道URI与File相似，你所有的操作如裁剪将数据都保存在了URI中，你已经持有了相应的URI，也就无需多此一举，再返回Bitmap了。</p>

<p>前面已经说到，可以设置data为Bitmap，但是这种操作的限制在于，你的Bitmap不能太大。因此，我们前进的思路似乎明确了：截大图用URI，小图用Bitmap。</p>

<p>我将这个思路整理成一张图片：</p>

<p><img src="/images/blog/android/151831_7gRC_245415.png" alt="idea" /></p>

<p>这篇主要让大家了解需求的来源，以及如何去思考分析并解决问题。下一篇博客将介绍具体的操作。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[【译】Android：更好的自定义字体方法]]></title>
    <link href="http://ryanhoo.github.io/blog/2014/05/05/android-better-way-to-apply-custom-font/"/>
    <updated>2014-05-05T17:48:26+08:00</updated>
    <id>http://ryanhoo.github.io/blog/2014/05/05/android-better-way-to-apply-custom-font</id>
    <content type="html"><![CDATA[<ul id="markdown-toc">
  <li><a href="#section">情景</a></li>
  <li><a href="#section-1">解决方案</a>    <ul>
      <li><a href="#android-1">1）Android默认方法 #1</a></li>
      <li><a href="#android-2">2）Android默认方法 #2</a></li>
      <li><a href="#section-2">3）我的解决方案</a></li>
    </ul>
  </li>
  <li><a href="#section-3">译者注</a></li>
  <li><a href="#section-4">参考</a></li>
</ul>

<blockquote>
  <p>原文：<a href="http://vision-apps.blogspot.hk/2012/02/android-better-way-to-apply-custom-font.html">http://vision-apps.blogspot.hk/2012/02/android-better-way-to-apply-custom-font.html</a></p>
</blockquote>

<p>在一个应用中，我需要在所有的UI组件中使用客户提供的字体。这听起来似乎是个很稀松平常的任务，不是吗？是的，我当时也是这么想的。然后我震惊了，Android竟然没有提供一个简单优雅的方式来做这件事情!</p>

<p>所以，在这篇文章中我会展示Android提供的默认方法，然后我会分享更加简单优雅的解决方案。</p>

<h3 id="section">情景</h3>

<p>你需要为整个应用替换自定义字体。</p>

<h3 id="section-1">解决方案</h3>

<h4 id="android-1">1）Android默认方法 #1</h4>

<p>你可以通过ID查找到View，然后挨个为它们设置字体。在单个View的情况下，它看起来也没有那么可怕。</p>

<p><code>java
Typeface customFont = Typeface.createFromAsset(this.getAssets(), "fonts/YourCustomFont.ttf");
TextView view = (TextView) findViewById(R.id.activity_main_header);
view.setTypeface(customFont);
</code></p>

<p>但是在很多TextView、Button等文本组件的情况下，我敢肯定你不会喜欢这个方法的。:D</p>

<h4 id="android-2">2）Android默认方法 #2</h4>

<p>你可以为每个文本组件创建一个子类，如TextView、Button等，然后在构造函数中加载自定义字体。</p>

<p>```java
public class BrandTextView extends TextView {</p>

<pre><code>  public BrandTextView(Context context, AttributeSet attrs, int defStyle) {
      super(context, attrs, defStyle);
  }
 public BrandTextView(Context context, AttributeSet attrs) {
      super(context, attrs);
  }
 public BrandTextView(Context context) {
      super(context);
 }
 public void setTypeface(Typeface tf, int style) {
       if (style == Typeface.BOLD) {
            super.setTypeface(Typeface.createFromAsset(getContext().getAssets(), "fonts/YourCustomFont_Bold.ttf"));
        } else {
           super.setTypeface(Typeface.createFromAsset(getContext().getAssets(), "fonts/YourCustomFont.ttf"));
        }
  }  } ```
</code></pre>

<p>然后只需要将标准的文本控件替换成你自定义的就可以了（例如BrandTextView替换TextView）。</p>

<p><code>xml
&lt;com.your.package.BrandTextView
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:text="View with custom font"/&gt;
&lt;com.your.package.BrandTextView
         android:layout_width="wrap_content"
         android:layout_height="wrap_content"
         android:textStyle="bold"
         android:text="View with custom font and bold typeface"/&gt;
</code></p>

<p>还有，你甚至可以直接在XML中添加自定义的字体属性。要实现这个，你需要定义你自己的<code>declare-styleable</code>属性，然后在组件的构造函数中解析它们。</p>

<p>为了不占篇幅介绍这么基础的东西，这里有一篇不错的文章告诉你怎么自定义控件属性。</p>

<blockquote>
  <p><a href="http://kevindion.com/2011/01/custom-xml-attributes-for-android-widgets/">http://kevindion.com/2011/01/custom-xml-attributes-for-android-widgets/</a></p>
</blockquote>

<p>在大多数情况下，这个方法还不赖，并且有一些优点（例如，切换字体粗细等等，字体可以在组件xml文件的typeface属性中定义）。但是我认为这个实现方法还是太重量级了，并且依赖大量的模板代码，为了一个替换字体的简单任务，有点儿得不偿失。</p>

<h4 id="section-2">3）我的解决方案</h4>

<p>理想的解决方案是自定义主题，然后应用到全局或者某个Activity。
但不幸的是，Android的<code>android:typeface</code>属性只能用来设置系统内嵌的字体，而非用户自定义字体(例如assets文件中的字体)。这就是为什么我们无法避免在Java代码中加载并设置字体。</p>

<p>所以我决定创建一个帮助类，使得这个操作尽可能的简单。使用方法：</p>

<p><code>
FontHelper.applyFont(context, findViewById(R.id.activity_root), "fonts/YourCustomFont.ttf");
</code></p>

<p>并且这行代码会用来加载所有的基于TextView的文本组件（TextView、Button、RadioButton、ToggleButton等等），而无需考虑界面的布局层级如何。</p>

<p><img src="/images/blog/2014-05-05-before and after.png" alt="标准(左)与自定义(右)字体的用法。" /></p>

<p>这是怎么做到的？非常简单：</p>

<p><code>java
public static void applyFont(final Context context, final View root, final String fontName) {
    try {
        if (root instanceof ViewGroup) {
            ViewGroup viewGroup = (ViewGroup) root;
            for (int i = 0; i &lt; viewGroup.getChildCount(); i++)
                applyFont(context, viewGroup.getChildAt(i), fontName);
        } else if (root instanceof TextView)
            ((TextView) root).setTypeface(Typeface.createFromAsset(context.getAssets(), fontName));
    } catch (Exception e) {
        Log.e(TAG, String.format("Error occured when trying to apply %s font for %s view", fontName, root));
        e.printStackTrace();
    }
}
</code></p>

<p>正如你所看到的，所需要做的仅仅是将基于TextView的文本组件从布局中遍历出来而已。</p>

<p>你可以在这里下载到示例代码，里面有<a href="http://db.tt/i9S80Mgr"><code>FontHelper</code></a>的具体用法。</p>

<h3 id="section-3">译者注</h3>

<p>在多个项目中，我都碰到过类似的需求，早期采用的是第二种实现方法，但是缺点在于对于第三方组件，你需要去修改别人的代码，才能实现自定义字体，这恰恰违反了OC（Open &amp; Close）原则，对扩展开放，对修改封闭。</p>

<p>刚看到第三种的时候，也是惊为天人，姑且不说结果，我觉得这种活跃的思路非常重要，很值得学习参考。</p>

<p>但是最后被team里的人否决了，理由是违背组件设计原则，实现方式略嫌粗暴。后来我仔细想想，一个是要做好内存管理（似乎会引起内存问题），视图状态改变，也要重复加载（横竖屏、onResume等），也绝对不是简单的活儿。</p>

<p>所以暂定使用第一种方法，typeface使用单例，需要时设置字体。</p>

<p>我个人觉得第一种还是个体力活，而且到后来，这个代码重复率还是非常高的，这又违背了DRY原则。</p>

<p>在地铁上的时候，突然想到DI（Dependency Inject）。已经有一些DI的框架，如ButterKnife，那写出来应该是这样：</p>

<p><code>
@CustomFont(R.id.textView) TextView textView
</code>
or</p>

<p><code>
@InjectView(id=R.id.textView, customFont=true) View anyView
@InjectView(id=R.id.textView, customFont=true, font="fonts/ltfz.ttf") View anyView
</code>
这样写出来代码相比重复写setTypeface要好一些。</p>

<p>目前我们的项目还没有使用这类DI框架，等以后引入了，使用第二种注入，写起来应该是很爽的。</p>

<p>保持更新。</p>

<h3 id="section-4">参考</h3>

<ul>
  <li><a href="http://www.javacodegeeks.com/2014/02/dependency-injection-options-for-java.html">DI框架</a></li>
  <li><a href="http://stormzhang.github.io/openandroid/android/2014/01/12/android-butterknife/">ButterKnife</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
